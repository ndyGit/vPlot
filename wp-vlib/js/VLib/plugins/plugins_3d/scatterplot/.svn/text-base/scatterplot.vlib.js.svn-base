/*
REFACTOR PARTICLE SYSTEM TO MESH.
TODO: COMPUTE AND ADD FACES TO GEOMETRYBUFFER POSITION.
LOOK AT: view-source:http://threejs.org/examples/webgl_interactive_buffergeometry.html
*/
define(
	[ 'require', 'config', 'core/AbstractPlugin.vlib', 'core/Utils.vlib','jquery', 'three','three_tween','./Animation.vlib','three_buffer' ],
	function(require, Config, AbstractPlugin,  UTILS, $,THREE,TWEEN,ANIMATION) {
		'use strict';
		/**
		TODO<br />
		@class Plugin ScatterPlot
		@constructor
		@extends AbstractPlugin
		**/
		var Plugin = (function(state) {
			var name = 'scatterplot';
			Plugin.superClass.constuctor.call(this,name);
			Plugin.superClass.setContext.call(this,Config.PLUGINTYPE.CONTEXT_3D);
			Plugin.superClass.setType.call(this,Config.PLUGINTYPE.PLOT);
			/** path to plugin-template file * */
			Plugin.superClass.setTemplates.call(this,Config.absPlugins+ '/plugins_3d/scatterplot/templates.js');
			Plugin.superClass.setIcon.call(this,Config.absPlugins+ '/plugins_3d/scatterplot/icon.png');
			Plugin.superClass.setAccepts.call(this,{
				predecessors : [ Config.PLUGINTYPE.CONTEXT_3D ],
				successors : [ Config.PLUGINTYPE.DATA,Config.PLUGINTYPE.AXES ]
			});
			Plugin.superClass.setDescription.call(this,'Requires: [ '+this.accepts.predecessors.join(', ')+' ] Accepts: [ '+this.accepts.successors.join(', ')+' ]');
			/** ********************************** */
			/** PRIVATE VARIABLES * */
			/** ********************************** */
			var renderedPS;
			var renderedMaterial;

			var particleSizeDefault = 10;
			var opacityDefault = 1;
			var blendingDefault = false;
			var colorsDefault = true;
			var transparentDefault = false;
			var ambientDefault = '#ff0000';
			var xScaleDefault = 400;
			var yScaleDefault = 400;
			var zScaleDefault = 400;

			var x_SCALE_MAX = 400;
			var x_SCALE_MIN = 0;
			var y_SCALE_MAX = 400;
			var y_SCALE_MIN = 0;
			var z_SCALE_MAX = 400;
			var z_SCALE_MIN = 0;
			if(state !== undefined){
					/*x_MAX = state.x_MAX;
					x_MIN = state.x_MIN;
					y_MAX = state.y_MAX;
					y_MIN = state.y_MIN;
					z_MAX = state.z_MAX;
					z_MIN = state.z_MIN;
					x_SCALE_MAX = state.x_SCALE_MAX;
					x_SCALE_MIN = state.x_SCALE_MIN;
					y_SCALE_MAX = state.y_SCALE_MAX;
					z_SCALE_MAX = state.z_SCALE_MAX;
					z_SCALE_MIN = state.z_SCALE_MIN;*/
				}
				/** ********************************** */
				/** PUBLIC VARIABLES * */
				/** ********************************** */

				/** ********************************** */
				/** PUBLIC METHODS * */
				/** ********************************** */
				/**
				 * Takes inserted configuration from the plugin-template and
				 * returns the parameters as JSON-config-file
				 *
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 *
				 * @return config file format:
				 *         {camera:{x:VALUE,y:VALUE,z:VALUE}}
				 */
				 this.deepCopy = function(){
				 	var privates = {
					/*x_MAX : x_MAX,
					x_MIN : x_MIN,
					y_MAX : y_MAX,
					y_MAX : y_MAX,
					y_MIN : y_MIN,
					z_MAX : z_MAX,
					z_MIN : z_MIN,
					x_SCALE_MAX : x_SCALE_MAX,
					x_SCALE_MIN : x_SCALE_MIN,
					y_SCALE_MAX : y_SCALE_MAX,
					y_SCALE_MIN : y_SCALE_MIN,
					z_SCALE_MAX : z_SCALE_MAX,
					z_SCALE_MIN : z_SCALE_MIN*/

				};
				return new Plugin(privates);
			};
			this.getConfigCallback = function(containerId) {

				var particleSize = $('#' + containerId + ' #particleSize')
				.val();
				var opacity = $('#' + containerId + ' #opacity').val();
				var image =  $('#' + containerId + ' #image').val();
				var blending = $('#' + containerId + ' #blending').is(':checked');
				var transparent = $('#' + containerId + ' #transparent').is(':checked');
				var colors = $('#' + containerId + ' #colors').is(':checked');
				var ambient = $('#' + containerId + ' #ambient').val();

				var xScale = $('#' + containerId + ' #xScale').val();

				var yScale = $('#' + containerId + ' #yScale').val();

				var zScale = $('#' + containerId + ' #zScale').val();

				var result = {
					material : {
						'particleSize' : particleSize === '' ? particleSizeDefault
						: particleSize,
						'opacity' : opacity === '' ? opacityDefault
						: opacity,
						'image' : image,
						'blending' : blending === '' ? blendingDefault
						: blending,
						'transparent' : transparent === '' ? transparentDefault
						: transparent,
						'colors' : colors === '' ? colorsDefault : colors,
						'ambient' : ambient === '' ? ambientDefault
						: ambient
					},
					scale : {
						'x' : xScale === '' ? xScaleDefault : xScale,
						'y' : yScale === '' ? yScaleDefault : yScale,
						'z' : zScale === '' ? zScaleDefault : zScale

					}

				};
				return result;

			};
				/**
				 * Takes arguments from config and inserts them to the
				 * plugin-template
				 *
				 * @param config
				 *            plugin config file
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 */
				 this.setConfigCallback = function(config, containerId) {
				 	console.log('[ scatter2 ][setConfig] fly:'+this.flyweightId);
				 	if (config === '') {
				 		config = {};
				 	}
				 	if (config.material === undefined){
				 		config.material = {};
				 	}
				 	if(config.material.particleSize === undefined){
				 		config.material.particleSize = 10;
				 	}
				 	if(config.material.opacity === undefined){
				 		config.material.opacity = 1;
				 	}
				 	if(config.material.colors === undefined){
				 		config.material.colors = true;
				 	}
				 	if (config.scale === undefined){
				 		config.scale = {};
				 	}
				 	if(config.scale.x === undefined){
				 		config.scale.x = xScaleDefault;
				 	}
				 	if(config.scale.y === undefined){
				 		config.scale.y = yScaleDefault;
				 	}
				 	if(config.scale.z === undefined){
				 		config.scale.z = zScaleDefault;
				 	}


				 	if (config.material.particleSize !== undefined) {
				 		$('#' + containerId ).find('#particleSize').val(
				 			config.material.particleSize);
				 	} else {

				 		$('#' + containerId ).find('#particleSize').val(
				 			particleSizeDefault);
				 		config.material.particleSize = particleSizeDefault;
				 	}
				 	if (config.material.opacity !== undefined) {
				 		$('#' + containerId ).find('#opacity').val(
				 			config.material.opacity);
				 	} else {
				 		$('#' + containerId ).find('#opacity').val(opacityDefault);
				 		config.material.opacity = opacityDefault;
				 	}
				 	if (config.material.image !== undefined) {
				 		$('#' + containerId + ' #image').val(
				 			config.material.image);
				 		$('#' + containerId ).find('#iamgeSelect').val(config.material.image).attr('selected', 'selected');
				 	}
				 	if (config.material.blending !== undefined) {
				 		if(config.material.blending === true){
				 			$('#' + containerId + ' #blending').attr('checked','checked');
				 		}
				 	}
				 	if (config.material.transparent !== undefined) {
				 		if(config.material.transparent === true){
				 			$('#' + containerId + ' #transparent').attr('checked','checked');
				 		}
				 	}
				 	if (config.material.colors !== undefined) {
				 		if(config.material.colors === true){
				 			$('#' + containerId ).find('#colors').attr('checked','checked');
				 		}
				 	}else{
				 		$('#' + containerId ).find('#colors').attr('checked','checked');
				 	}
				 	if (config.material.ambient !== undefined) {
				 		$('#' + containerId + ' #ambient').val(
				 			config.material.ambient);
				 	} else {
				 		$('#' + containerId + ' #ambient').val(ambientDefault);
				 	}
				 	if (config.scale.x !== undefined) {
				 		$('#' + containerId + ' #xScale').val(config.scale.x);
				 	} else {
				 		$('#' + containerId + ' #xScale').val(xScaleDefault);
				 	}
				 	if (config.scale.y !== undefined) {
				 		$('#' + containerId + ' #yScale').val(config.scale.y);
				 	} else {
				 		$('#' + containerId + ' #yScale').val(yScaleDefault);
				 	}
				 	if (config.scale.z !== undefined) {
				 		$('#' + containerId + ' #zScale').val(config.scale.z);
				 	} else {
				 		$('#' + containerId + ' #zScale').val(zScaleDefault);
				 	}

					// particleSizeSlider
					$('#' + containerId ).find(' #particleSizeSlider').slider({
						orientation: 'horizontal',
						range: 'min',
						min: 1,
						max: 200,
						value: config.material.particleSize,
						slide: function (event, ui) {
							$('#' + containerId ).find('#particleSize').val(ui.value);
							if(renderedMaterial !== undefined){
								renderedMaterial.size = ui.value;
							}
						}
					});
				// opacitySlider
				$('#' + containerId ).find(' #opacitySlider').slider({
					orientation: 'horizontal',
					range: 'min',
					min: 0,
					max: 100,
					value: config.material.opacity*100,
					slide: function (event, ui) {
						$('#' + containerId ).find('#opacity').val(ui.value/100);
						if(renderedMaterial !== undefined){
							renderedMaterial.opacity = ui.value/100;
						}
					}
				});
				$('#' + containerId ).find(' #iamgeSelect').change(function(){
					var selected = $(this).find('option:selected');
					$('#' + containerId ).find(' #image').val(selected.val());
					if(renderedMaterial !== undefined){
						renderedMaterial.map = THREE.ImageUtils.loadTexture(Config.baseData+'/'+selected.val());
					}
				});
				if(renderedMaterial !== undefined){

					$('#' + containerId ).find('#colors').on('change',function(){
						if($(this).is(':checked')){
							renderedMaterial.vertexColors = true;
							renderedPS.geometry.attributes.color.needsUpdate = true;
							renderedPS.geometry.colorsNeedUpdate = true;

						}else{
							renderedMaterial.vertexColors = false;
							renderedPS.geometry.attributes.color.needsUpdate = true;
							renderedPS.geometry.colorsNeedUpdate = true;
						}
					});
				}


			};


			this.exec = function(config, childs,buffer) {
				console.log('[ scatterplot ] \t\t EXEC');
				var result = [];
				if (config === '') {
					config = {};
				}
				if (config.material === undefined){
					config.material = {};
				}
				if(config.material.particleSize === undefined){
					config.material.particleSize = 10;
				}
				if(config.material.opacity === undefined){
					config.material.opacity = 1;
				}
				if(config.material.colors === undefined){
					config.material.colors = true;
				}
					// set scaling
					if (config.hasOwnProperty('scale')) {
						x_SCALE_MAX = config.scale.x;
						y_SCALE_MAX = config.scale.y;
						z_SCALE_MAX = config.scale.z;
					}
					var borders = {
						xMax : 'auto',
						yMax : 'auto',
						zMax : 'auto',
						xMin : 'auto',
						yMin : 'auto',
						zMin : 'auto'
					};




					/** *********************************** * */
					/** HANDLE SUCCESSOR PLUGINGS * */
					/** *********************************** * */
					var data = [];
					var colors = [];
					var axesSet = false;
					var heatmaps = [];
					var axesCallback;
					var axesContext;
					var child;
					for ( var i = 0; i < childs.length; ++i) {
						child = childs[i];
						if(child !== undefined && child.pType !== undefined){
							if($.inArray(child.pType, this.accepts.successors) != -1){
								switch(child.pType){
									case Config.PLUGINTYPE.DATA:
									var tmpData = child.response.data;
									var tmpColor = child.response.colorArray;
									if(child.response.heatmap !== undefined){
										heatmaps.push(child.response.heatmap);
									}
									data = data.concat(tmpData);
									colors = colors.concat(tmpColor);
									break;
									case Config.PLUGINTYPE.AXES:
									axesCallback = child.response.callback;
									axesContext = child.response.context;
									borders.xMax = child.response.rangeX;
									borders.yMax = child.response.rangeY;
									borders.zMax = child.response.rangeZ;
									axesSet = true;
									break;
								}
							}
						}else{
							console.log('pType of child plugin not set!');
						}
					}
					if(data.length === 0) return;

					/** *********************************** */
					/** GET MAX VALUES * */
					/** CHECK RANGE - auto * */
					var minMax = UTILS.C3D.getMinMax(data);
					borders.xMax = borders.xMax  != 'auto' ? borders.xMax : minMax.xMax;
					borders.yMax = borders.yMax  != 'auto' ? borders.yMax : minMax.yMax;
					borders.zMax = borders.zMax  != 'auto' ? borders.zMax : minMax.zMax;
					borders.xMin = borders.xMin  != 'auto' ? borders.xMin : minMax.xMin;
					borders.yMin = borders.yMin  != 'auto' ? borders.yMin : minMax.yMin;
					borders.zMin = borders.zMin  != 'auto' ? borders.zMin : minMax.zMin;

					/** *********************************** */
					/** handle data * */
					var scaled_data = scale(data,borders);





					var geometry = new THREE.BufferGeometry();
					geometry.addAttribute( 'position', Float32Array, scaled_data.length, 3 );
					geometry.addAttribute( 'color', Float32Array, scaled_data.length, 3 );
					var gPositions = geometry.attributes.position.array;
					var gColors = geometry.attributes.color.array;
					var gColor = new THREE.Color();
					for ( var i = 0, dataIndex = 0; i < gPositions.length,dataIndex < scaled_data.length; i += 3, dataIndex++ ) {
						// positions
						var coord = scaled_data[dataIndex];
						gPositions[ i ] = coord.x;
						gPositions[ i + 1 ] = coord.y;
						gPositions[ i + 2 ] = coord.z;
						// colors
						//console.log(coord.x+','+coord.y+','+coord.z+" => vc: "+colors[dataIndex]);
						gColor.setStyle('#'+colors[dataIndex]);
						gColors[ i ] = gColor.r;
						gColors[ i + 1 ] = gColor.g;
						gColors[ i + 2 ] = gColor.b;
					}
					geometry.computeBoundingSphere();


					/** *********************************** */
					/** handle axes * */
					if (axesSet) {
						var axes = axesCallback.apply(axesContext, [ data, scaled_data,colors,
							x_SCALE_MAX, y_SCALE_MAX, z_SCALE_MAX, borders, minMax, heatmaps ]);
						for ( var index = 0; index < axes.length; ++index) {
							// add axes to scene
							result.push(axes[index]);
						}
					}
					/** *********************************** */
					/** handle config && plot * */

					var materialConfig = {};
					materialConfig.color = 0xFFFFFF;
					materialConfig.vertexColors = config.material.colors;
					materialConfig.opacity = config.material.opacity;
					materialConfig.size = config.material.particleSize;
					materialConfig.transparent = config.material.transparent === '' ? false
					: config.material.transparent;
					materialConfig.ambient = config.material.ambient === undefined ? '#808080'
					: '#' + config.material.ambient;


					if (config.material.blending !== undefined && config.material.blending === true) {
						console.log('[ scatterplot ] blending is deactivated!');
						//materialConfig.blending = THREE.AdditiveBlending;
					}


					if (config.material.image !== undefined && config.material.image.length > 0) {
						materialConfig.map = THREE.ImageUtils
						.loadTexture(Config.baseData+'/'+config.material.image);
					}
					var material = new THREE.ParticleBasicMaterial(
						materialConfig);


					var particleSystem = new THREE.ParticleSystem(geometry,
						material);
					particleSystem.sortParticles = true;
					particleSystem.geometry.verticesNeedUpdate = true;
					particleSystem.geometry.colorsNeedUpdate = true;
					particleSystem.geometry.attributes.position.needsUpdate = true;
					particleSystem.geometry.attributes.color.needsUpdate = true;
					renderedMaterial = material;
					renderedPS = particleSystem;
					psClone = particleSystem.geometry.clone();
					/*
						TODO: REFACTOR ME
						THIS IS JUST A TEST :)
*/
var button1 = document.getElementById( 'testTransformXYZ' );
button1.addEventListener( 'click', function ( event ) {
	projectXYZ( particleSystem, 1 );
	particleSystem.geometry.verticesNeedUpdate = true;
	particleSystem.updateMatrix();
	open = !open;
}, false );
var button2 = document.getElementById( 'testTransformXY' );
button2.addEventListener( 'click', function ( event ) {
	projectXY( particleSystem, 1 );
	particleSystem.geometry.verticesNeedUpdate = true;
	particleSystem.updateMatrix();
	open = !open;
}, false );
var button3 = document.getElementById( 'testTransformXZ' );
button3.addEventListener( 'click', function ( event ) {
	projectXZ( particleSystem, 1 );
	particleSystem.geometry.verticesNeedUpdate = true;
	particleSystem.updateMatrix();
	open = !open;
}, false );
var button4 = document.getElementById( 'testTransformYZ' );
button4.addEventListener( 'click', function ( event ) {
	var target = renderedPS.geometry.clone();
	/* set target.x to 0*/
	for(var i = 0, len = target.attributes.position.array.length; i < len; i+=3){
		target.attributes.position.array[i] = 0;
	}
	ANIMATION.TWEEN.GEOMETRY.project(particleSystem,target,1000);

						//projectYZ( particleSystem, 1000 );
						particleSystem.geometry.verticesNeedUpdate = true;
						particleSystem.updateMatrix();
						open = !open;
					}, false );



result.push(particleSystem);

		// intersectionObjects.push(particleSystem);
		return {
			pType : this.type,
			response : result
		};

	};
	var open = false;
	var psClone;
	/* TWEEN FOR BUFFERED GEOMETRIES*/
	var projectXYZ = function ( object, duration ) {

		var gPositionsOriginal = psClone.attributes.position.array;
		var gPositions = object.geometry.attributes.position.array;
		var target,helper;
		for(var i = 0, len = gPositions.length; i < len; i+=3){

			helper = new THREE.Vector3(gPositions[i],gPositions[i+1],gPositions[i+2]);
			target = { x : gPositionsOriginal[i], y: gPositionsOriginal[i+1], z : gPositionsOriginal[i+2] };

			TweenMax.to(helper, Math.random() * duration, {
				ease:TWEEN.Easing.Quintic.InOut,
				x: target.x,
				y: target.y,
				z: target.z,
				onUpdateParams : ["{self}",object,gPositions,i],
				onUpdate : function(tween,system,positionArray,index){
					positionArray[index] = tween.target.x;
					positionArray[index+1] = tween.target.y;
					positionArray[index+2] = tween.target.z;
					system.geometry.attributes.position.needsUpdate = true;
				}
			});

		}
	}
	var projectXY = function ( object, duration ) {
		var gPositionsOriginal = psClone.attributes.position.array;
		var gPositions = object.geometry.attributes.position.array;
		var target,helper;
		for(var i = 0, len = gPositions.length; i < len; i+=3){

			helper = new THREE.Vector3(gPositions[i],gPositions[i+1],gPositions[i+2]);
			target = { x : gPositionsOriginal[i], y: gPositionsOriginal[i+1], z : 0 };

			TweenMax.to(helper, Math.random() *duration, {
				ease:TWEEN.Easing.Bounce.Out,
				x: target.x,
				y: target.y,
				z: target.z,
				onUpdateParams : ["{self}",object,gPositions,i],
				onUpdate : function(tween,system,positionArray,index){
					positionArray[index] = tween.target.x;
					positionArray[index+1] = tween.target.y;
					positionArray[index+2] = tween.target.z;
					system.geometry.attributes.position.needsUpdate = true;
				}
			});

		}
	}
	var projectXZ = function ( object, duration ) {
		var gPositionsOriginal = psClone.attributes.position.array;
		var gPositions = object.geometry.attributes.position.array;
		var target,helper;
		for(var i = 0, len = gPositions.length; i < len; i+=3){

			helper = new THREE.Vector3(gPositions[i],gPositions[i+1],gPositions[i+2]);
			target = { x : gPositionsOriginal[i], y: 0, z : gPositionsOriginal[i+2]  };

			TweenMax.to(helper, Math.random() *duration, {
				ease:TWEEN.Easing.Back.InOut,
				x: target.x,
				y: target.y,
				z: target.z,
				onUpdateParams : ["{self}",object,gPositions,i],
				onUpdate : function(tween,system,positionArray,index){
					positionArray[index] = tween.target.x;
					positionArray[index+1] = tween.target.y;
					positionArray[index+2] = tween.target.z;
					system.geometry.attributes.position.needsUpdate = true;
				}
			});

		}
	}
	var projectYZ = function ( object, duration ) {



		var gPositionsOriginal = psClone.attributes.position.array;
		var gPositions = object.geometry.attributes.position.array;
		var target,helper,params;

		for(var i = 0, len = gPositions.length; i < len; i+=3){

			helper = {
				x:gPositions[i],
				y:gPositions[i+1],
				z:gPositions[i+2]
			};
			target = {
				x : 0,
				y: gPositionsOriginal[i+1],
				z : gPositionsOriginal[i+2]
			};
			params = {
				index : i,
				system : object
			};

			var tween = new TWEEN.Tween( helper,params);
			tween.to(target, Math.random() *duration);
			tween.easing(TWEEN.Easing.Back.InOut);
			tween.onUpdate(function(o,args){
				var positionArray = args.system.geometry.attributes.position.array;
				positionArray[args.index] = this.x;
				positionArray[args.index+1] = this.y;
				positionArray[args.index+2] = this.z;
				args.system.geometry.attributes.position.needsUpdate = true;
			});

			tween.start();

		}
	}

	// /* TEST TWEEN NORMAL GEOMETRY*/
	// var transform = function ( object, duration ) {

	// 				// TWEEN.removeAll();
	// 				var vertex = object.geometry.vertices;
	// 				var target;

	// 				for(var i = 0, len = vertex.length; i < len; ++i){
	// 					//object.geometry.attributes.position.array[i+2] = 0;

	// 					target = { x : vertex[i].x, y: vertex[i].y, z : 0 };
	// 					TweenLite.to(vertex[i], 4, {
	// 						x: target.x,
	// 						y: target.y,
	// 						z: target.z,
	// 						onUpdateParams : ["{self}",object,i],
	// 						onUpdate : function(tween,system,index){

	// 							system.geometry.vertices[index].x = tween.target.x;
	// 							system.geometry.vertices[index].y = tween.target.y;
	// 							system.geometry.vertices[index].z = tween.target.z;
	// 							system.geometry.verticesNeedUpdate = true;
	// 						}
	// 					});

	// 				}
	// 			}
	/** ********************************** */
	/** PRIVATE METHODS * */
	/** ********************************** */

	var scale = function(data,borders) {

		var b2 = {
			'x_MAX':borders.xMax,
			'y_MAX':borders.yMax,
			'z_MAX':borders.zMax,
			'x_MIN':borders.xMin,
			'y_MIN':borders.yMin,
			'z_MIN':borders.zMin,
			'x_SCALE_MIN' : x_SCALE_MIN,
			'y_SCALE_MIN' : y_SCALE_MIN,
			'z_SCALE_MIN' : z_SCALE_MIN,
			'x_SCALE_MAX' : x_SCALE_MAX,
			'y_SCALE_MAX' : y_SCALE_MAX,
			'z_SCALE_MAX' : z_SCALE_MAX,
		};
		return UTILS.C3D.scaleLinearToRange(data,b2);
	};
});
UTILS.CLASS.extend(Plugin,AbstractPlugin);
return Plugin;

});
