define(
	[ 'require', 'config', 'core/Utils.vlib','core/Buffer.vlib', 'core/AbstractPlugin.vlib', 'three','three_tween', 'jquery','libs/Detector','libs/stats','libs/animFrame' ],
	function(require, Config,UTILS,Buffer, AbstractPlugin, THREE, Tween,$) {
		'use strict';
			/**
			TODO<br />
			@class Plugin 3D
			@constructor
			@extends AbstractPlugin
			**/

			var Plugin = (function(state) {
				var name = '3d';
				Plugin.superClass.constuctor.call(this,name);
				Plugin.superClass.setContext.call(this,Config.PLUGINTYPE.CONTEXT_3D);
				Plugin.superClass.setType.call(this,Config.PLUGINTYPE.CONTEXT_3D);
				/** path to plugin-template file * */
				Plugin.superClass.setTemplates.call(this,Config.absPlugins+ '/plugins_3d/3d/templates.js');
				Plugin.superClass.setIcon.call(this,Config.absPlugins+ '/plugins_3d/3d/icon.png');
				Plugin.superClass.setAccepts.call(this,{
					predecessors : [ Config.PLUGINTYPE.ROOT ],
					successors : [ Config.PLUGINTYPE.PLOT,
					Config.PLUGINTYPE.LIGHT, Config.PLUGINTYPE.CAMERA ]
				});
				Plugin.superClass.setDescription.call(this,'Requires: [ '+this.accepts.predecessors.join(', ')+' ] Accepts: [ '+this.accepts.successors.join(', ')+' ]');



				/** ********************************** */
				/** PRIVATE VARIABLES * */
				/** ********************************** */

				var animationFrameId;
				var sceneHeightDefault = 'auto';
				var sceneWidthDefault = 'auto';
				var container = $('body');

				var camXDefault = 0;
				var camYDefault = 0;
				var camZDefault = 1000;

				var sceneObjects = [];
				var stats = null;
				var camera = null;
				//camera control callback
				var cccall;
				//camera control context
				var cccon;
				var scene = null;
				var renderer = null;
				var controls = null;
				var clock = null;
				var running = false;

				// var mouseX, mouseY, projector;
				// var intersectionObjects = [];
				// var intersectionObjectsData = [];

				if(state !== undefined){
					sceneHeightDefault = state.sceneHeightDefault;
					sceneWidthDefault = state.sceneWidthDefault;
					container = state.container;
					camXDefault = state.camXDefault;
					camYDefault = state.camYDefault;
					camZDefault = state.camZDefault;
					camera = state.camera;
					scene = state.scene;
					renderer = state.renderer;
					controls = state.controls;
					clock = state.clock;
					running = state.running;

				}
				/** ********************************** */
				/** PUBLIC VARIABLES * */
				/** ********************************** */

				/** ********************************** */
				/** PUBLIC METHODS * */
				/** ********************************** */
				this.deepCopy = function(){
					var privates = {
						sceneHeightDefault	: sceneHeightDefault,
						sceneWidthDefault	: sceneWidthDefault,
						container			: container,
						camXDefault		: camXDefault,
						camYDefault		: camYDefault,
						camZDefault		: camZDefault,
						camera		: camera,
						scene		: scene,
						renderer	: renderer,
						controls	: controls,
						clock		: clock,
						running		: running,
							// no need to copy state of intersection stuff. they are just short-time buffers
						};
						return new Plugin(privates);
					};
				/**
				 * Takes inserted configuration from the plugin-template and
				 * returns the parameters as JSON-config-file
				 *
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 *
				 * @return config file format:
				 *         {camera:{x:VALUE,y:VALUE,z:VALUE}}
				 */
				 this.getConfigCallback = function(containerId) {

				 	var c = $('#'+containerId);
				 	var antialias = c.find('#antialias').is(':checked');
				 	var alpha = c.find('#alpha').is(':checked');

				 	var sceneWidth = c.find('#sceneWidth').val();
				 	var sceneHeight = c.find('#sceneHeight').val();
				 	var camX = c.find('#camX').val();
				 	var camY = c.find('#camY').val();
				 	var camZ = c.find('#camZ').val();

				 	if(camX === '' || camX === undefined){
				 		camX = camXDefault;
				 	}
				 	if(camY === '' || camY === undefined){
				 		camY = camYDefault;
				 	}
				 	if(camZ === '' || camZ === undefined){
				 		camZ = camZDefault;
				 	}
				 	var result = {
				 		antialias : antialias,
				 		alpha : alpha,
				 		scene : {
				 			width : sceneWidth,
				 			height : sceneHeight
				 		},
				 		camera : {
				 			x : camX ,
				 			y : camY ,
				 			z : camZ
				 		}
				 	};
				 	console.log('[ 3d ][getConfig] ' + JSON.stringify(result));
				 	return result;
				 };
				/*
				 * Takes arguments from config and inserts them to the
				 * plugin-template
				 *
				 * @param config
				 *            plugin config file
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 */
				 this.setConfigCallback = function(config, containerId) {

				 	var c = $('#'+containerId);
				 	if (config === undefined ){
				 		config = {
				 			scene : {width:'auto',height:'auto'},
				 			camera : {x:camXDefault,y:camYDefault,z:camZDefault},
				 			alpha : false,
				 			antialias : true
				 		};
				 	}
				 	if(config.scene === undefined){
				 		config.scene =  {width:'auto',height:'auto'};
				 	}
				 	if(config.camera === undefined){
				 		config.camera =  {x:0,y:0,z:1000};
				 	}
				 	if (config.antialias !== undefined) {
				 		if(config.antialias === true){
				 			c.find('#antialias').attr('checked','checked');
				 		}
				 	}
				 	if (config.alpha !== undefined) {
				 		if(config.alpha === true){
				 			$('#' + containerId + ' #alpha').attr('checked','checked');
				 		}
				 	}
				 	if (config.scene.width !== undefined) {
				 		c.find('#sceneWidth')
				 		.val(config.scene.width);
				 	} else {
				 		c.find('#sceneWidth')
				 		.val(sceneWidthDefault);
				 	}
				 	if (config.scene.height !== undefined) {
				 		c.find('#sceneHeight')
				 		.val(config.scene.height);
				 	} else {
				 		c.find('#sceneHeight')
				 		.val(sceneHeightDefault);
				 	}
				 	if (config.camera.x !== undefined) {
				 		c.find('#camX').val(
				 			config.camera.x);
				 	} else {
				 		c.find('#camX').val(
				 			camXDefault);
				 	}
				 	if (config.camera.y !== undefined) {

				 		c.find('#camY').val(
				 			config.camera.y);
				 	} else {
				 		c.find('#camY').val(
				 			camYDefault);
				 	}
				 	if (config.camera.z !== undefined) {
				 		c.find('#camZ').val(
				 			config.camera.z);
				 	} else {
				 		c.find('#camZ').val(
				 			camZDefault);
				 	}
				 	/* INTERACTIVE */
				 	/* update camera movement*/
				 	setInterval(function(){
				 		c.find('#camX').val(camera.position.x+ " "+camera.rotation.x);
				 		c.find('#camY').val(camera.position.y+ " "+camera.rotation.y);
				 		c.find('#camZ').val(camera.position.z + " "+camera.rotation.z);
				 	},1000);
				 };

				 this.exec = function(config, childs, buffer) {

				 	console.log(this.id+'[ 3d ] \t\t EXEC '+running);


				 	if (config.scene === undefined) {
				 		config.scene = {width:'auto',height:'auto'};
				 	}
				 	if (config.camera === undefined) {
				 		config.camera ={x:0,y:0,z:1000};
				 	}
				 	if (config.container !== undefined) {
				 		container = $('#'+config.container);
				 	}else{
				 		alert('plugin 3d ERROR: NO RENDER CONTAINER GIVEN!');
				 	}
				 	if(config.alpha === undefined ){
				 		config.alpha = false;
				 	}
				 	if(config.antialias === undefined ){
				 		config.antialias = true;
				 	}

				 	var width = ((config.scene.width === undefined) || (config.scene.width === 'auto')) ? container
				 	.width() : config.scene.width;

				 	var height = ((config.scene.height === undefined) || (config.scene.height === 'auto'))  ? container
				 	.height() : config.scene.height;

					//check if min-height is set
					if(height === 0){
						height = container.css('min-height');

					}
					//default
					if(height === 0){
						height = Config.DEFAULT_PLOT_HEIGHT;
					}
					var camX = config.camera.x === undefined ? camXDefault
					: config.camera.x;
					var camY = config.camera.y === undefined ? camYDefault
					: config.camera.y;
					var camZ = config.camera.z === undefined ? camZDefault
					: config.camera.z;


					// ********************************* init
					if(true/*running*/){

						if ( Detector.webgl ){
							renderer = new THREE.WebGLRenderer({
								antialias : config.antialias,
								alpha: config.alpha,
								preserveDrawingBuffer: true
							});
							// renderer.shadowMapEnabled = true;
							// renderer.shadowMapType = THREE.PCFShadowMap;
						}else{
							Detector.addGetWebGLMessage();
						}

						renderer.sortObjects = true;
						renderer.setSize(width, height);

						clock = new THREE.Clock();
						camera = new THREE.PerspectiveCamera(45, (width / height),
							1, 10000);


						scene = new THREE.Scene();
						renderer.setClearColor( 0xffffff, 1);

						stats = new Stats();
						stats.domElement.style.position = 'relative';
						stats.domElement.style.width = '100%';
						stats.domElement.style.top = '0px';
						container.parent().find('#plotStats').html( stats.domElement );

						scene.add(camera);
						camera.position.set(camX, camY, camZ);
						camera.lookAt(scene.position);


						// scene.add( new THREE.AmbientLight( 0x505050 ) );
						// var light = new THREE.SpotLight( 0xffffff, 1.5 );
						// light.position.set( 0, 500, 2000 );
						// light.castShadow = true;

						// light.shadowCameraNear = 200;
						// light.shadowCameraFar = camera.far;
						// light.shadowCameraFov = 50;

						// light.shadowBias = -0.00022;
						// light.shadowDarkness = 0.5;

						// light.shadowMapWidth = 2048;
						// light.shadowMapHeight = 2048;
						// scene.add( light );



						this.start();
					}

					// ********************************* scene


					sceneObjects = [];
					var child;
					for ( var i = 0; i < childs.length; ++i) {
						child = childs[i];
						if(child !== undefined && child.pType !== undefined){
							if($.inArray(child.pType, this.accepts.successors) != -1){
								switch(child.pType){
									case Config.PLUGINTYPE.CAMERA:
									cccall = child.response.callback;
									cccon = child.response.callbackObj;
									resetCameraControler();

									break;
									case Config.PLUGINTYPE.LIGHT:
									sceneObjects.push(child.response);
									break;
									case Config.PLUGINTYPE.PLOT:
									var plotObj;
									for ( var index = 0; index < child.response.length; ++index) {
										plotObj = child.response[index];
										//plotObj.rotation.x = -Math.PI / 2;
										sceneObjects.push(plotObj);
									}
									break;
									default:
										// add geometry
										for ( index = 0; index < child.response.length; ++index) {
											sceneObjects.push(child.response[index]);
										}
										break;
									}
								}
							}else{
								console.log('pType of child plugin not set!');
							}
						}

						for(i = 0; i < sceneObjects.length;++i){
							scene.add(sceneObjects[i]);
						}

						console.log('[ plugin ][ 3d ] sceneSize( ' + width + ' x ' + height +' )');
						console.log('[ plugin ][ 3d ] cameraPosition( ' + camX + ', ' + camY + ', ' + camZ + ' )');




					//document.addEventListener('click', onDocumentMouseDown,false);
					window.addEventListener( 'resize', onWindowResize, false );
					renderer.domElement.addEventListener('mouseover', resetCameraControler, true);

					return renderer;

				};


				var resetCameraControler = function(){
					console.log('reset controler');
					if(cccall === undefined || cccon === undefined) return;
					controls = cccall.apply(cccon, [camera, renderer, container ]);
				};
				// var onDocumentMouseDown = function(event) {

				// 	event.preventDefault();

				// 	var vector = new THREE.Vector3(
				// 		((window.innerWidth - ( window.innerWidth - event.clientX)) / container.innerWidth) * 2 - 1,
				// 		-((window.innerHeight - ( window.innerHeight - event.clientY)) / container.innerHeight) * 2 + 1, 0.5);

				// 	projector.unprojectVector(vector, camera);

				// 	var raycaster = new THREE.Raycaster(camera.position, vector
				// 		.sub(camera.position).normalize());

				// 	var intersects = raycaster.intersectObjects(scene.children,true);

				// 	if (intersects.length > 0) {
				// 		var ip = intersects[0].point;
				// 		console.log('click intersection: point( ',ip.x+ ', '+ip.y+', '+ip.z+' )');

				// 	}

				// };
				this.stop = function(){
					console.log(id+' stopping animation frame loop!');
					if(animationFrameId !== undefined){
						 //cancelRequestAnimationFrame(animationFrameId);
						 cancelRequestAnimFrame(animationFrameId);
						 animationFrameId = undefined;
						}
					//reset
					for(var i = 0; i < sceneObjects.length;++i){
						scene.remove(sceneObjects[i]);
						sceneObjects[i].deallocateObject();
					}
					sceneObjects = [];

					stats = null;
					camera = null;
					cccall;
					cccon;
					scene = null;
					renderer = null;
					controls = null;
					clock = null;

					running = false;
				};

				this.start = function(){
					running = true;
					if(!animationFrameId){
						console.log('starting animation frame loop!');
						animate.apply(this, []);
					}
				};
				/** ********************************** */
				/** PRIVATE METHODS * */
				/** ********************************** */
				var animate = function() {

					animationFrameId = requestAnimFrame(animate);
					render.apply(this, []);
				};
				this.getId = function(){
					return id;
				};
				/**
				* Renders the current state
				*/
				var render = function() {

					if (controls !== null) {
						var delta = clock.getDelta();
						controls.update(delta);
					}
					renderer.render(scene, camera);
					TWEEN.update();
					if(stats !== null && stats !== undefined) stats.update();


				};

				var onWindowResize = function(){
					camera.aspect = container.width() / container.height();
					camera.updateProjectionMatrix();
					renderer.setSize( container.width(), container.height() );
				};

			});
UTILS.CLASS.extend(Plugin,AbstractPlugin);
return Plugin;
});
