define(['require','config','core/AbstractPlugin.vlib','core/Utils.vlib','libs/parser'],function(require,Config,AbstractPlugin,UTILS) {
	/**
		TODO<br />
		@class Plugin Function
		@constructor
		@extends AbstractPlugin
	**/
	var Plugin = (function() {
		var name = 'function';
		Plugin.superClass.constuctor.call(this,name);
		Plugin.superClass.setContext.call(this,Config.PLUGINTYPE.CONTEXT_3D);
		Plugin.superClass.setType.call(this,Config.PLUGINTYPE.FUNCTION);
		/** path to plugin-template file * */
		Plugin.superClass.setTemplates.call(this,Config.absPlugins+ '/plugins_3d/fun/templates.js');
		Plugin.superClass.setIcon.call(this,Config.absPlugins+ '/plugins_3d/fun/icon.png');
		Plugin.superClass.setAccepts.call(this,{
			predecessors : [ Config.PLUGINTYPE.DATA ],
			successors : [  ]
		});
		Plugin.superClass.setDescription.call(this,'Requires: [ '+this.accepts.predecessors.join(', ')+' ] Accepts: [ '+this.accepts.successors.join(', ')+' ]');
		/** ********************************** */
		/** PUBLIC VARIABLES * */
		/** ********************************** */

		this.color = '000000';
		this.zFun;
		/** ********************************** */
		/** PUBLIC METHODS * */
		/** ********************************** */
		/**
		 * Takes inserted configuration from the plugin-template and
		 * returns the parameters as JSON-config-file
		 *
		 * @param containerId
		 *            parent container where the plugin-template got
		 *            added
		 *
		 * @return config file format:
		 *         { path:VALUE,data:VALUE}
		 */
		 this.getConfigCallback = function(containerId) {
		 	var zFun = $('#' + containerId).find('#zFun')
		 	.val();
		 	var result = {
		 		'zFun' : zFun
		 	};
		 	console.log("[ fun ][getConfig] "+JSON.stringify(result));
		 	return result;
		 }
		/**
		 * Takes arguments from config and inserts them to the
		 * plugin-template
		 *
		 * @param config
		 *            plugin config file
		 * @param containerId
		 *            parent container where the plugin-template got
		 *            added
		 */
		 this.setConfigCallback = function(config, containerId) {
		 	console.log("[ color ][setConfig] "+JSON.stringify(config));
		 	if(config === undefined){
		 		config = {zFun:'sin(sqrt(x^2  + y^2))'};
		 	}
		 	if(config.zFun === undefined){
		 		config.zFun = 'sin(sqrt(x^2  + y^2))';
		 	}
		 	var zFun = $('#' + containerId).find('#zFun').val(config.zFun);


		 }
		 var callbackFunction = function(data){
			//SCELETON
			alert("functionCallback");
			return data;
		}
		var execZFun = function(data){
			var result = [];
			var newPoint;
			for(var i = 0; i < data.length; ++i){
				newPoint = {
					x : data[i].x,
					y : data[i].y,
					z : this.zFun(data[i].x,data[i].y,data[i].z)
				}
				// fix me
				if(isNaN(newPoint.z))
					newPoint.z = 0;

				result.push(newPoint);
			}

			return result;
		}
		/*Parser:
		* https://github.com/silentmatt/js-expression-eval/tree/master
		*/
		this.exec = function(config) {
			console.log("[ color ] \t\t EXEC");
			if(config == null || config === undefined || config == '')
				return;
			if(config.zFun === undefined || config.zFun == '')
				return;

			this.zFun = Parser.parse(config.zFun).toJSFunction( ['x','y','z'] );
			return {
				pType : this.type,
				response : {
					callback : execZFun,
					context : this
				}
			};
		}


	});
UTILS.CLASS.extend(Plugin,AbstractPlugin);
return Plugin;

});
