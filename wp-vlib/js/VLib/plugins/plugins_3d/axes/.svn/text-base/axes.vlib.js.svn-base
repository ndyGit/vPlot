define(
	[ 'require', 'config', 'core/AbstractPlugin.vlib','core/Utils.vlib', 'three', 'jquery'/*, 'three_font_helveticer'*/ ],
	function(require, Config,AbstractPlugin, UTILS, THREE, $) {
		/**
			TODO<br />
			@class Plugin Axes
			@constructor
			@extends AbstractPlugin
			**/
			var Plugin = (function(state) {
				var name = 'axes';
				Plugin.superClass.constuctor.call(this,name);
				Plugin.superClass.setContext.call(this,Config.PLUGINTYPE.CONTEXT_3D);
				Plugin.superClass.setType.call(this,Config.PLUGINTYPE.AXES);
				/** path to plugin-template file * */
				Plugin.superClass.setTemplates.call(this,Config.absPlugins+ '/plugins_3d/axes/templates.js');
				Plugin.superClass.setIcon.call(this,Config.absPlugins+ '/plugins_3d/axes/icon.png');
				Plugin.superClass.setAccepts.call(this,{
					predecessors : [ Config.PLUGINTYPE.PLOT ],
					successors : [Config.PLUGINTYPE.COLOR]
				});
				Plugin.superClass.setDescription.call(this,'Requires: [ '+this.accepts.predecessors.join(', ')+' ] Accepts: [ '+this.accepts.successors.join(', ')+' ]');
				/** ********************************** */
				/** PRIVATE VARIABLES * */
				/** ********************************** */
				var xLabel = 'x';
				var yLabel = 'y';
				var zLabel = 'z';
				var xRange = 'auto';
				var yRange = 'auto';
				var zRange = 'auto';
				var granularityX = 2;
				var granularityY = 2;
				var granularityZ = 2;

				var xRangeDefault = 'auto';
				var yRangeDefault = 'auto';
				var zRangeDefault = 'auto';
				var fontSize = 20;
				var decimalPlaces = 7;

				/** ********************************** */
				/** PUBLIC VARIABLES * */
				/** ********************************** */
				this.config = null;
				this.labelColor = 0x373530;
				this.numUnitsDefault = 2;

				if(state !== undefined){
					xLabel = state.xLabel;
					yLabel = state.yLabel;
					zLabel = state.zLabel;
					xRange = state.xRange;
					yRange = state.yRange;
					zRange = state.zRange;
					this.config = state.config;
					this.labelColor = state.labelColor;

				}
				/** ********************************** */
				/** PUBLIC METHODS * */
				/** ********************************** */
				this.deepCopy = function(){
					var privates = {
						xLabel : xLabel,
						yLabel : yLabel,
						zLabel : zLabel,
						xRange : xRange,
						yRange : yRange,
						zRange : zRange,
						config : this.config,
						labelColor : this.labelColor
					};
					return new Plugin(privates);
				}
				/**
				 * Takes inserted configuration from the plugin-template and
				 * returns the parameters as JSON-config-file
				 *
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 *
				 * @return config file format:
				 *         {camera:{x:VALUE,y:VALUE,z:VALUE}}
				 */
				 this.getConfigCallback = function(containerId) {
				 	var x = $('#' + containerId + ' > form input[id=xLabel]')
				 	.val();
				 	var y = $('#' + containerId + ' > form input[id=yLabel]')
				 	.val();
				 	var z = $('#' + containerId + ' > form input[id=zLabel]')
				 	.val();
				 	var dataLabels = $('#' + containerId + ' #dataLabels').is(':checked');
				 	var showValueRange = $('#' + containerId + ' #showValueRange').is(':checked');
				 	var showHeatmapRange = $('#' + containerId + ' #showHeatmapRange').is(':checked');

				 	xRange = $('#' + containerId + ' #xRange').val();

				 	yRange = $('#' + containerId + ' #yRange').val();

				 	zRange = $('#' + containerId + ' #zRange').val();

				 	granularityX = $('#' + containerId + ' #granularity-x').val();
				 	granularityY = $('#' + containerId + ' #granularity-y').val();
				 	granularityZ = $('#' + containerId + ' #granularity-z').val();

				 	//RASTER
				 	var rasterXY = $('#' + containerId + ' #xy-raster-show').is(':checked');
				 	var rasterXYOpacity =  $('#' + containerId + ' #raster-xy').val();

				 	var rasterXZ = $('#' + containerId + ' #xz-raster-show').is(':checked');
				 	var rasterXZOpacity =  $('#' + containerId + ' #raster-xz').val();

				 	var rasterYZ = $('#' + containerId + ' #yz-raster-show').is(':checked');
				 	var rasterYZOpacity =  $('#' + containerId + ' #raster-yz').val();

				 	var result = {
				 		labels : {
				 			'x' : x === "" ? xLabel : x,
				 			'y' : y === "" ? yLabel : y,
				 			'z' : z === "" ? zLabel : z,
				 			'data' : dataLabels
				 		},
				 		range : {
				 			'x' : xRange === "" ? "auto" : xRange,
				 			'y' : yRange === "" ? "auto" : yRange,
				 			'z' : zRange === "" ? "auto" : zRange
				 		},
				 		valueRange : showValueRange,
				 		heatmapRange : showHeatmapRange,
				 		numUnits : {
				 			'x' : granularityX,
				 			'y' : granularityY,
				 			'z' : granularityZ,
				 		},
				 		raster : {
				 			xy : {
				 				show : rasterXY,
				 				opacity : rasterXYOpacity
				 			},
				 			xz : {
				 				show : rasterXZ,
				 				opacity : rasterXZOpacity
				 			},
				 			yz : {
				 				show : rasterYZ,
				 				opacity : rasterYZOpacity
				 			}
				 		}
				 	};
				 	console
				 	.log("[ axes ][getConfig] "
				 		+ JSON.stringify(result));
				 	return result;
				 }
				/**
				 * Takes arguments from config and inserts them to the
				 * plugin-template
				 *
				 * @param config
				 *            plugin config file
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 */
				 this.setConfigCallback = function(config, containerId) {
				 	console
				 	.log("[ axes ][setConfig] "
				 		+ JSON.stringify(config));
				 	if (config == "" || config === undefined){
				 		config = {
				 			labels : '',
				 			range : '',
				 			valueRange : false,
				 			heatmapRange : false,
				 			numUnits : {},
				 			raster:{}
				 		};
				 	}
				 	if (!config.hasOwnProperty('labels'))
				 		config.labels = '';
				 	if (!config.hasOwnProperty('range'))
				 		config.range = '';
				 	if (!config.hasOwnProperty('numUnits'))
				 		config.numUnits = {};
				 	if (!config.hasOwnProperty('raster'))
				 		config.raster = {};

				 	if (config.labels.x != undefined) {
				 		$('#' + containerId + ' > form input[id=xLabel]').val(
				 			config.labels.x);
				 	} else {
				 		$('#' + containerId + ' > form input[id=xLabel]').val(
				 			xLabel);
				 	}
				 	if (config.labels.y != undefined) {
				 		$('#' + containerId + ' > form input[id=yLabel]').val(
				 			config.labels.y);
				 	} else {
				 		$('#' + containerId + ' > form input[id=yLabel]').val(
				 			yLabel);
				 	}
				 	if (config.labels.z != undefined) {
				 		$('#' + containerId + ' > form input[id=zLabel]').val(
				 			config.labels.z);
				 	} else {
				 		$('#' + containerId + ' > form input[id=zLabel]').val(
				 			zLabel);
				 	}
				 	if (config.labels.data != undefined) {
				 		if(config.labels.data === true){
				 			$('#' + containerId ).find(' #dataLabels').attr('checked','checked');
				 		}
				 	}
				 	if (config.valueRange != undefined) {
				 		if(config.valueRange === true){
				 			$('#' + containerId ).find(' #showValueRange').attr('checked','checked');
				 		}
				 	}
				 	if (config.heatmapRange != undefined) {
				 		if(config.heatmapRange === true){
				 			$('#' + containerId ).find(' #showHeatmapRange').attr('checked','checked');
				 		}
				 	}

				 	if (config.range.x != undefined) {
				 		$('#' + containerId + ' #xRange').val(config.range.x);
				 	} else {
				 		$('#' + containerId + ' #xRange').val(xRangeDefault);
				 	}
				 	if (config.range.y != undefined) {
				 		$('#' + containerId + ' #yRange').val(config.range.y);
				 	} else {
				 		$('#' + containerId + ' #yRange').val(yRangeDefault);
				 	}
				 	if (config.range.z != undefined) {
				 		$('#' + containerId + ' #zRange').val(config.range.z);
				 	} else {
				 		$('#' + containerId + ' #zRange').val(zRangeDefault);
				 	}
				 	if (config.numUnits !== undefined) {
				 		if (config.numUnits.x !== undefined) {
				 			$('#' + containerId ).find(' #granularity-x').val(config.numUnits.x);
				 		} else {
				 			$('#' + containerId ).find(' #granularity-x').val(this.numUnitsDefault);
				 			config.numUnits.x = this.numUnitsDefault;
				 		}
				 		if (config.numUnits.y !== undefined) {
				 			$('#' + containerId ).find(' #granularity-y').val(config.numUnits.y);
				 		} else {
				 			$('#' + containerId ).find(' #granularity-y').val(this.numUnitsDefault);
				 			config.numUnits.y = this.numUnitsDefault;
				 		}
				 		if (config.numUnits.z !== undefined) {
				 			$('#' + containerId ).find(' #granularity-z').val(config.numUnits.z);
				 		} else {
				 			$('#' + containerId ).find(' #granularity-z').val(this.numUnitsDefault);
				 			config.numUnits.z = this.numUnitsDefault;
				 		}
				 	}else{
				 		config.numUnits = {};
				 		config.numUnits.x  = this.numUnitsDefault;
				 		config.numUnits.y  = this.numUnitsDefault;
				 		config.numUnits.z  = this.numUnitsDefault;

				 	}
				 	// RASTER
				 	if(config.raster.xy !== undefined){
				 		if(config.raster.xy.show !== undefined){
				 			if(config.raster.xy.show === true){
				 				$('#' + containerId ).find(' #xy-raster-show').attr('checked','checked');
				 			}
				 		}else{
				 			config.raster.xy.show = false;
				 		}
				 		if(config.raster.xy.opacity !== undefined && config.raster.xy.opacity !== ""){
				 			$('#' + containerId ).find(' #raster-xy').val(config.raster.xy.opacity);
				 		}else{
				 			$('#' + containerId ).find(' #raster-xy').val(0.06);
				 		}
				 	}else{
				 		config.raster.xy = {};
				 		config.raster.xy.show = false;
				 		config.raster.xy.opacity = 0.06;
				 		$('#' + containerId ).find(' #raster-xy').val(0.06);
				 	}
				 	if(config.raster.xz !== undefined){
				 		if(config.raster.xz.show !== undefined){
				 			if(config.raster.xz.show === true){
				 				$('#' + containerId ).find(' #xz-raster-show').attr('checked','checked');
				 			}
				 		}else{
				 			config.raster.xz.show = false;
				 		}
				 		if(config.raster.xz.opacity !== undefined && config.raster.xz.opacity !== ""){
				 			$('#' + containerId ).find(' #raster-xz').val(config.raster.xz.opacity);
				 		}else{
				 			$('#' + containerId ).find(' #raster-xz').val(0.06);
				 		}
				 	}else{
				 		config.raster.xz = {};
				 		config.raster.xz.show = false;
				 		config.raster.xz.opacity = 0.06;
				 		$('#' + containerId ).find(' #raster-xz').val(0.06);
				 	}
				 	if(config.raster.yz !== undefined){
				 		if(config.raster.yz.show !== undefined){
				 			if(config.raster.yz.show === true){
				 				$('#' + containerId ).find(' #yz-raster-show').attr('checked','checked');
				 			}
				 		}else{
				 			config.raster.yz.show = false;
				 		}
				 		if(config.raster.yz.opacity !== undefined && config.raster.yz.opacity !== ""){
				 			$('#' + containerId ).find(' #raster-yz').val(config.raster.yz.opacity);
				 		}else{
				 			$('#' + containerId ).find(' #raster-yz').val(0.06);
				 		}
				 	}else{
				 		config.raster.yz = {};
				 		config.raster.yz.show = false;
				 		config.raster.yz.opacity = 0.06;
				 		$('#' + containerId ).find(' #raster-yz').val(0.06);
				 	}


				 		// slider
				 		$('#' + containerId ).find(' #granularitySliderX').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 13,
				 			value: config.numUnits.x,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #granularity-x').val(ui.value);
				 			}
				 		});
				 		$('#' + containerId ).find(' #granularitySliderY').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 13,
				 			value: config.numUnits.y,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #granularity-y').val(ui.value);
				 			}
				 		});
				 		$('#' + containerId ).find(' #granularitySliderZ').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 13,
				 			value: config.numUnits.z,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #granularity-z').val(ui.value);
				 			}
				 		});
				 		$('#' + containerId ).find(' #raster-xy-slider').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 1,
				 			step: 0.01,
				 			value: config.raster.xy.opacity,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #raster-xy').val(ui.value);
				 			}
				 		});
				 		$('#' + containerId ).find(' #raster-xz-slider').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 1,
				 			step: 0.01,
				 			value: config.raster.xz.opacity,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #raster-xz').val(ui.value);
				 			}
				 		});
				 		$('#' + containerId ).find(' #raster-yz-slider').slider({
				 			orientation: "horizontal",
				 			range: "min",
				 			min: 0,
				 			max: 1,
				 			step: 0.01,
				 			value: config.raster.yz.opacity,
				 			slide: function (event, ui) {
				 				$('#' + containerId + ' #raster-yz').val(ui.value);
				 			}
				 		});
				 	}

				 	this.exec = function(config, childs) {
				 		console.log("[ plugin ][ axes ] \t\t EXECUTE");
				 		this.config = config;
				 		/*
					 * HANDLE CONFIG
					 */
					 if(this.config == '' || this.config === null || this.config === undefined){
					 	this.config = {
					 		labels:{x:'x',y:'y',z:'z'},
					 		range:{x:xRangeDefault,y:yRangeDefault,z:zRangeDefault},
					 		raster:{
					 			xy:{show:false,opacity:0.2},
					 			xz:{show:false,opacity:0.2},
					 			yz:{show:false,opacity:0.2}
					 		}
					 	};
					 }
					 if (this.config.numUnits === null
					 	|| this.config.numUnits === undefined) {
					 	this.config.numUnits = {x:this.numUnitsDefault,y:this.numUnitsDefault,z:this.numUnitsDefault};
					}
					if(this.config.numUnits.x === undefined){
						this.config.numUnits.x = this.numUnitsDefault;
					}
					if(this.config.numUnits.y === undefined){
						this.config.numUnits.y = this.numUnitsDefault;
					}
					if(this.config.numUnits.z === undefined){
						this.config.numUnits.z = this.numUnitsDefault;
					}

					// set labels
					if (config.labels !== undefined) {
						xLabel = config.labels.x === undefined ? 'x'
						: config.labels.x;
						yLabel = config.labels.y === undefined ? 'y'
						: config.labels.y;
						zLabel = config.labels.z === undefined ? 'z'
						: config.labels.z;
					}
					// set range
					if (config.range !== undefined) {
						xRange = config.range.x === undefined ? xRangeDefault
						: config.range.x;
						yRange = config.range.y === undefined ? yRangeDefault
						: config.range.y;
						zRange = config.range.z === undefined ? zRangeDefault
						: config.range.z;
					}
					if(config.raster === undefined){
						this.config.raster = {
							xy:{show:false},
							xz:{show:false},
							yz:{show:false}
						};
					}
					if(config.valueRange === undefined){
						this.config.valueRange = false;
					}
					if(config.heatmapRange === undefined){
						this.config.heatmapRange = false;
					}

					/** *********************************** * */
					/** HANDLE SUCCESSOR PLUGINGS * */
					/** *********************************** * */
					var child = undefined;
					for ( var i = 0; i < childs.length; ++i) {
						child = childs[i];
						if(child !== undefined && child.pType !== undefined){
							if($.inArray(child.pType, this.accepts.successors) != -1){
								switch(child.pType){

									case Config.PLUGINTYPE.COLOR:
									this.labelColor = '#'+child.response.color;

									break;
								}
							}
						}else{
							console.log("pType of child plugin not set!");
						}
					}


					return {
						pType : this.type,
						response : {
							// callback
							'callback' : getAxes,
							'context' : this,
							'rangeX' : xRange,
							'rangeY' : yRange,
							'rangeZ' : zRange
						}
					};

				}

				/** ********************************** */
				/** PRIVATE METHODS * */
				/** ********************************** */
				/*
				* @param b
					borders set by user
				* @param db
					calculated data-borders
					*/
					var getAxes = function(dataArray, dataPositionArray,colorArray, x, y, z,
						b,db, heatmaps) {

						var result = [];
						/* make shure that we calculate with floats*/
						var borders = {
							xMax : Math.max(parseFloat(b.xMax),parseFloat(b.xMin)),
							yMax : Math.max(parseFloat(b.yMax),parseFloat(b.yMin)),
							zMax : Math.max(parseFloat(b.zMax),parseFloat(b.zMin)),
							xMin : parseFloat(b.xMin),
							yMin : parseFloat(b.yMin),
							zMin : parseFloat(b.zMin),
						}
						var dataBorders = {
							xMax : Math.max(parseFloat(db.xMax),parseFloat(db.xMin)),
							yMax : Math.max(parseFloat(db.yMax),parseFloat(db.yMin)),
							zMax : Math.max(parseFloat(db.zMax),parseFloat(db.zMin)),
							xMin : parseFloat(db.xMin),
							yMin : parseFloat(db.yMin),
							zMin : parseFloat(db.zMin),
						}

						/* take borders into account during position calculation */
						var xr = borders.xMax;
						var xPos = x*(Math.abs(borders.xMax)/xr);
						var xNeg = x*(Math.abs(borders.xMin)/xr);
						if(borders.xMin < 0) xNeg *= -1;

						var yr = borders.yMax;
						var yPos = y*(Math.abs(borders.yMax)/yr);
						var yNeg = y*(Math.abs(borders.yMin)/yr);
						if(borders.yMin < 0) yNeg *= -1;

						var zr = borders.zMax;
						var zPos = z*(Math.abs(borders.zMax)/zr);
						var zNeg = z*(Math.abs(borders.zMin)/zr);
						if(borders.zMin < 0) zNeg *= -1;


						var dzr = dataBorders.zMax;

						var dataXPos = x*(Math.abs(dataBorders.xMax)/xr);
						var dataXNeg = x*(Math.abs(dataBorders.xMin)/xr);
						if(dataBorders.xMin < 0) dataXNeg *= -1;
						var dataYPos = y*(Math.abs(dataBorders.yMax)/yr);
						var dataYNeg = y*(Math.abs(dataBorders.yMin)/yr);
						if(dataBorders.yMin < 0) dataYNeg *= -1;
						var dataZPos = z*(Math.abs(dataBorders.zMax)/zr);
						var dataZNeg = z*(Math.abs(dataBorders.zMin)/zr);
						if(dataBorders.zMin < 0) dataZNeg *= -1;


					/*
					 * add axes plot dimension x,y,z
					 */
					 var lineX = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(x, 0, 0));
					 var lineY = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(0, y, 0));
					 var lineZ = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(0, 0, z));

					 var lineXNeg = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(-x, 0, 0));
					 var lineYNeg = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(0, -y, 0));
					 var lineZNeg = getLine(new THREE.Vector3(0, 0, 0),
					 	new THREE.Vector3(0, 0, -z));


					/*
					 * add axes - range
					 */
					 var lineDimX = getDashedLine(
					 	new THREE.Vector3(dataXPos, 0, 0),
					 	new THREE.Vector3(dataXNeg, 0, 0),
					 	2,this.labelColor);


					 var lineDimY = getDashedLine(
					 	new THREE.Vector3(0, dataYPos, 0),
					 	new THREE.Vector3(0, dataYNeg, 0),2,this.labelColor);

					 var lineDimZ = getDashedLine(
					 	new THREE.Vector3(0, 0, dataZPos),
					 	new THREE.Vector3(0, 0, dataZNeg),
					 	2,this.labelColor);

					 var lineDimXStart = getLine(
					 	new THREE.Vector3(dataXPos, 0, -6),
					 	new THREE.Vector3(dataXPos, 0, 6),
					 	2,this.labelColor);
					 var lineDimXEnd = getLine(
					 	new THREE.Vector3(dataXNeg, 0, -6),
					 	new THREE.Vector3(dataXNeg, 0, 6),
					 	2,this.labelColor);
					 var lineDimYStart = getLine(
					 	new THREE.Vector3(0, dataYPos, -6),
					 	new THREE.Vector3(0, dataYPos, 6),
					 	2,this.labelColor);
					 var lineDimYEnd = getLine(
					 	new THREE.Vector3(0, dataYNeg, -6),
					 	new THREE.Vector3(0, dataYNeg, 6),
					 	2,this.labelColor);
					 var lineDimZStart = getLine(
					 	new THREE.Vector3(-6, 0, dataZPos),
					 	new THREE.Vector3(6, 0, dataZPos),
					 	2,this.labelColor);
					 var lineDimZEnd = getLine(
					 	new THREE.Vector3(-6, 0, dataZNeg),
					 	new THREE.Vector3(6, 0, dataZNeg),
					 	2,this.labelColor);


					 if(this.config.heatmapRange !== undefined &&
					 	this.config.heatmapRange === true){
					 	if(heatmaps.length > 0){

					 		var heatmap;
					 		for(var i = 0; i < heatmaps.length; ++i){
					 			heatmap = heatmaps[i];

					 			if(heatmap.numberRange !== undefined && heatmap.spectrum !== undefined){
					 				var from = z*(Math.abs(parseFloat(heatmap.numberRange.from))/zr);
					 				var to = z*(Math.abs(parseFloat(heatmap.numberRange.to))/zr);
					 				if(parseFloat(heatmap.numberRange.from) < 0){
					 					from *= -1;
					 				}
					 				var hmLine = getHeatmapLine(
					 					new THREE.Vector3(0,0,from),
					 					new THREE.Vector3(0,0,to),
					 					heatmap.spectrum.from,
					 					heatmap.spectrum.to
					 					,4);
					 				hmStarter = getLine(
					 					new THREE.Vector3(-10, 0, from),
					 					new THREE.Vector3(10, 0, from),
					 					3,'#'+heatmap.spectrum.from
					 					);
					 				hmEnd = getLine(
					 					new THREE.Vector3(-10, 0, to),
					 					new THREE.Vector3(10, 0, to),
					 					3,'#'+heatmap.spectrum.to
					 					);
					 				result.push(hmStarter);
					 				result.push(hmLine);
					 				result.push(hmEnd);
					 			}

					 		}
					 	}
					 }

					 if(this.config.valueRange !== undefined &&
					 	this.config.valueRange === true){
					 	result.push(lineDimX);
					 result.push(lineDimY);
					 result.push(lineDimZ);
					 result.push(lineDimXStart);
					 result.push(lineDimXEnd);
					 result.push(lineDimYStart);
					 result.push(lineDimYEnd);
					}

					result.push(lineX);
					result.push(lineY);
					result.push(lineZ);
					result.push(lineXNeg);
					result.push(lineYNeg);
					result.push(lineZNeg);


					/*
					 * add description
					 */
					 var w, h;
					 w = (xLabel.length) * (fontSize / 2);
					 h = fontSize + 5;
					 var labelX = getLabel(xLabel, x, -h, 0, w, h);
					 w = (yLabel.length) * (fontSize / 2);
					 var labelY = getLabel(yLabel, 0, y+h, 0, w, h);
					 w = (zLabel.length) * (fontSize / 2);
					 var labelZ = getLabel(zLabel, -h / 2, -h, z, w, h);

					 result.push(labelX);
					 result.push(labelY);
					 result.push(labelZ);


					/***********************************************************
					 * LABELING
					 */
					// -2 due to seperate push of "0" and "max" labels
					var numIntermedateUnitsX = parseInt(this.config.numUnits.x -2);
					var numIntermedateUnitsY = parseInt(this.config.numUnits.y -2);
					var numIntermedateUnitsZ = parseInt(this.config.numUnits.z -2);


					/***************************
					 * add range values to x
					 */

					// add zero value
					if(this.config.numUnits.x > 0 || this.config.numUnits.y > 0 || this.config.numUnits.z > 0){
						var wx = "0".toString().length * (fontSize / 2);
						result.push(getLabel(0, 0, -h / 2, 0, wx, h));
					}
					// add max value
					if(this.config.numUnits.x >=2){

						var dx = borders.xMax;
						var wx = dx.toString().length * (fontSize / 2);
						result.push(getLabel(dx, xPos + wx, -h / 2, 0, wx, h));
						// push guideline
						result.push(getLine(
							new THREE.Vector3(xPos, -6, 0),
							new THREE.Vector3(xPos, 6, 0)));

					}
					// add min value
					if(this.config.numUnits.x >=2){
						var dx = -1*borders.xMax;
						var wx = dx.toString().length * (fontSize / 2);

						result.push(getLabel(dx, -1*xPos, -h / 2, 0, wx, h));
					// push guideline
					result.push(getLine(
						new THREE.Vector3(xNeg, -6, 0),
						new THREE.Vector3(xNeg, 6, 0)));
				}
					// add intermediate positive values
					if(this.config.numUnits.x >2){
						var stepValue = parseFloat((borders.xMax / (numIntermedateUnitsX + 1)).toFixed(2));

						var stepRange = xPos / (numIntermedateUnitsX + 1);
						var dx = 0;
						var xp = 0;
						for ( var i = 1; i <= numIntermedateUnitsX; ++i) {
							// push value
							dx += stepValue;
							dx = parseFloat(dx.toFixed(decimalPlaces));
							var wx = dx.toString().length * (fontSize / 2);
							xp += stepRange;

							var label = getLabel(dx, xp, -h / 2, 0, wx, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(xp, -6, 0),
								new THREE.Vector3(xp, 6, 0)));
						}
						// add intermediate negative values
						var dx = 0;
						var xp = 0;
						for ( var i = 1; i <= numIntermedateUnitsX; ++i) {
							// push value
							dx -= stepValue;
							dx = parseFloat(dx.toFixed(decimalPlaces));
							var wx = dx.toString().length * (fontSize / 2);
							xp -= stepRange;

							var label = getLabel(dx, xp, -h / 2, 0, wx, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(xp, -6, 0),
								new THREE.Vector3(xp, 6, 0)));
						}
					}
					/***************************
					 * add range values to y
					 */

					// add max value
					if(this.config.numUnits.y >= 2){
						var dy = borders.yMax;
						var wy = dy.toString().length * (fontSize / 2);
						result.push(getLabel(dy,-h / 2, yPos, 0, wy, h));
						// push guideline
						result.push(getLine(
							new THREE.Vector3(-6, yPos, 0),
							new THREE.Vector3(6, yPos, 0)));
					}
					// add min value
					if(this.config.numUnits.y >= 2){
						var dy = -1*borders.yMax;
						var wy = dy.toString().length * (fontSize / 2);
						result.push(getLabel(dy, -h / 2, -1*yPos, 0, wy, h));
						result.push(getLine(
							new THREE.Vector3(-6, -1*yPos, 0),
							new THREE.Vector3(6, -1*yPos, 0)));
					}

					// add intermediate positive values
					if(this.config.numUnits.y > 2){
						var stepValue = parseFloat((borders.yMax / (numIntermedateUnitsY + 1))
							.toFixed(2));

						var stepRange = yPos / (numIntermedateUnitsY + 1);
						var dy = 0;
						var yp = 0;
						for ( var i = 1; i <= numIntermedateUnitsY; ++i) {
							dy += stepValue;
							dy = parseFloat(dy.toFixed(decimalPlaces));
							var wy = dy.toString().length * (fontSize / 2);
							yp += stepRange;

							var label = getLabel(dy, -h / 2, yp, 0, wy, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(-6, yp, 0),
								new THREE.Vector3(6, yp, 0)));
						}
						// add intermediate negative values

						var dy = 0;
						var yp = 0;
						for ( var i = 1; i <= numIntermedateUnitsY; ++i) {
							dy -= stepValue;
							dy = parseFloat(dy.toFixed(decimalPlaces));
							var wy = dy.toString().length * (fontSize / 2);
							yp -= stepRange;
							var label = getLabel(dy, -h / 2, yp, 0, wy, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(-6, yp, 0),
								new THREE.Vector3(6, yp, 0)));
						}
					}
					/***************************
					 * add range values to z
					 */

					// add max value
					if(this.config.numUnits.z >= 2){
						var dz = borders.zMax;
						var wz = dz.toString().length * (fontSize / 2);
						result.push(getLabel(dz,-h / 2, 0,zPos, wz, h));
						// push guideline
						result.push(getLine(
							new THREE.Vector3(-6, 0, zPos),
							new THREE.Vector3(6, 0, zPos)));
					}
					// add min value
					if(this.config.numUnits.z >= 2){
						var dz = -1*borders.zMax;
						var wz = dz.toString().length * (fontSize / 2);
						result.push(getLabel(dz, -h / 2, 0, -1*zPos, wz, h));
						// push guideline
						result.push(getLine(
							new THREE.Vector3(-6, 0, zNeg),
							new THREE.Vector3(6, 0, zNeg)));
					}
					// add intermediate positive values
					if(this.config.numUnits.z > 2){
						var stepValue = parseFloat((borders.zMax / (numIntermedateUnitsZ + 1))
							.toFixed(2));

						var stepRange = zPos / (numIntermedateUnitsZ + 1);
						var dz = 0;
						var zp = 0;
						for ( var i = 1; i <= numIntermedateUnitsZ; ++i) {
							dz += stepValue;
							dz = parseFloat(dz.toFixed(decimalPlaces));
							var wz = dz.toString().length * (fontSize / 2);
							zp += stepRange;

							var label = getLabel(dz, -h / 2, 0, zp, wz, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(-6, 0, zp),
								new THREE.Vector3(6, 0, zp)));
						}
						// add intermediate negative values
						var dz = 0;
						var zp = 0;
						for ( var i = 1; i <= numIntermedateUnitsZ; ++i) {
							dz -= stepValue;
							dz = parseFloat(dz.toFixed(decimalPlaces));
							var wz = dz.toString().length * (fontSize / 2);
							zp -= stepRange;

							var label = getLabel(dz, -h / 2, 0, zp, wz, h);
							result.push(label);
							// push guideline
							result.push(getLine(
								new THREE.Vector3(-6, 0, zp),
								new THREE.Vector3(6, 0, zp)));
						}
					}
					// RASTER XY
					if(this.config.raster.xy.show === true){
						var floorTexture = new THREE.ImageUtils.loadTexture( Config.absPlugins+'/plugins_3d/3d/checkerboard.jpg' );
						floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
						floorTexture.repeat.set( (this.config.numUnits.x-1)/2, (this.config.numUnits.z-1)/2 );
						var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide,
							transparent : true,
							opacity: this.config.raster.xy.opacity,
							depthWrite: false, depthTest: false } );
						var floorGeometry = new THREE.PlaneGeometry(2*xPos, 2*yPos, 8, 8);
						var floor = new THREE.Mesh(floorGeometry, floorMaterial);
						floor.position.y = 0;
						result.push(floor);
					}
					// RASTER XZ
					if(this.config.raster.xz.show === true){
						var floorTexture = new THREE.ImageUtils.loadTexture( Config.absPlugins+'/plugins_3d/3d/checkerboard.jpg' );
						floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
						floorTexture.repeat.set( (this.config.numUnits.x-1)/2, (this.config.numUnits.z-1)/2 );
						var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide,
							transparent : true,
							opacity: this.config.raster.xz.opacity,
							depthWrite: false, depthTest: false } );
						var floorGeometry = new THREE.PlaneGeometry(2*xPos, 2*zPos, 8, 8);
						var floor = new THREE.Mesh(floorGeometry, floorMaterial);
						floor.position.y = 0;
						floor.rotation.x = Math.PI / 2;
						result.push(floor);
					}
					// RASTER YZ
					if(this.config.raster.yz.show === true){
						var floorTexture = new THREE.ImageUtils.loadTexture( Config.absPlugins+'/plugins_3d/3d/checkerboard.jpg' );
						floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
						floorTexture.repeat.set( (this.config.numUnits.y-1)/2, (this.config.numUnits.z-1)/2 );
						var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide,
							transparent : true,
							opacity: this.config.raster.yz.opacity,
							depthWrite: false, depthTest: false } );
						var floorGeometry = new THREE.PlaneGeometry(2*yPos, 2*zPos, 8, 8);
						var floor = new THREE.Mesh(floorGeometry, floorMaterial);
						floor.position.y = 0;
						floor.rotation.y = Math.PI / 2;
						floor.rotation.x = Math.PI / 2;
						result.push(floor);
					}
					/***************************
					 * add data values
					 */
					 if(this.config.labels.data === true){
					 	var offset = h;
					 	for(var i = 0; i < dataPositionArray.length; ++i){
					 		var dx = '( '+dataArray[i].x+', '+dataArray[i].y+', '+dataArray[i].z+' )';
					 		var wx = dx.toString().length * (fontSize/2);

					 		var xPos = dataPositionArray[i].x ;
					 		var yPos = dataPositionArray[i].y ;
					 		var zPos = dataPositionArray[i].z ;
					 		xPos = xPos > 0 ? xPos+offset : xPos-offset;
					 		yPos = yPos > 0 ? yPos+offset : yPos-offset;
					//zPos = zPos > 0 ? zPos+offset : zPos-offset;
					var label = getLabel(dx,xPos,yPos,zPos,wx,h,this.labelColor);
					result.push(label);

				}
			}

			return result;
		}
		var getLabel = function(text, x, y, z, w, h,color) {
			var c = color === undefined ? "rgba(0, 0, 0, 0.5)" : color;

					 /* create a canvas element*/
					 var canvas = document.createElement('canvas');
					 var context = canvas.getContext('2d');
					 var padding = 10;
					 canvas.width = w + padding;
					 canvas.height = h + padding;
					 /* context.fillStyle = "#CC5422";*/
					 /* context.fillRect(0,0,w,h);*/
					 context.font = fontSize + "px Arial";
					 context.fillStyle = c;
					 context.fillText(text, 0, fontSize);

					// canvas contents will be used for a texture
					var texture = new THREE.Texture(canvas)
					texture.needsUpdate = true;
					// var material1 = new THREE.MeshBasicMaterial({
					// 	map : texture1,
					// 	side : THREE.DoubleSide
					// });
					// material1.transparent = true;
					// var textMesh = new THREE.Mesh(new THREE.PlaneGeometry(
					// 	canvas1.width, canvas1.height), material1);
					// textMesh.position.set(x, y, z);

					var spriteMaterial = new THREE.SpriteMaterial(
						{ map: texture } );
					var sprite = new THREE.Sprite( spriteMaterial );
					sprite.position.set(x, y, z);
					sprite.scale.set(w,h,1.0);
					sprite.rotate
					return sprite;
				}
				var getHeatmapLine = function(from, to, color1, color2, lineWidth) {
					var c1 = color1,c2 = color2;
					if(c1 === undefined){
						c1 = 'ffffff';
					}
					if(c2 === undefined){
						c2 = '000000'
					}

					var geometry = new THREE.Geometry();
					// heatmap range-line
					var threeColors = [new THREE.Color('#'+c1),new THREE.Color('#'+c2)];

					geometry.vertices.push( from,to );
					geometry.colors = threeColors;

					var heatMapLine = new THREE.Line( geometry,
						new THREE.LineBasicMaterial( {
							linewidth: lineWidth === undefined ? 3 : lineWidth,
							vertexColors: THREE.VertexColors

						} )
						);
					return heatMapLine;
				}

				/*
				 * @param from THREE.Vector3(x, y, z) @param to THREE.Vector3(x,
				 * y, z) @return THREE.Line
				 *
				 */
				 var getLine = function(from, to, lineWidth,c) {

				 	var geometry = new THREE.Geometry();
				 	geometry.vertices.push(from, to);

				 	return new THREE.Line(geometry, new THREE.LineBasicMaterial( {
				 		color: c === undefined ? 0x505050 : c,
				 		dashSize: 10,
				 		gapSize: 10,
				 		linewidth: lineWidth === undefined ? 1 : lineWidth,
				 	} ), THREE.LinePieces );

				 }
				 /*
				 * @param from THREE.Vector3(x, y, z) @param to THREE.Vector3(x,
				 * y, z) @return THREE.Line
				 *
				 */
				 var getDashedLine = function(from, to, lineWidth,c) {

				 	var geometry = new THREE.Geometry();
				 	geometry.vertices.push(from, to);
				 	geometry.computeLineDistances();

				 	return new THREE.Line(geometry, new THREE.LineDashedMaterial( {
				 		color: c === undefined ? 0x505050 : c,
				 		dashSize: 8,
				 		gapSize: 5,
				 		linewidth: lineWidth === undefined ? 1 : lineWidth,
				 	} ), THREE.LinePieces );

				 }

				});
UTILS.CLASS.extend(Plugin,AbstractPlugin);
return Plugin;
});
