define(
	[ 'require', 'config','core/AbstractPlugin.vlib', 'core/Utils.vlib', 'three' ],
	function(require, Config,AbstractPlugin, UTILS, THREE) {
		/**
		TODO<br />
		@class Plugin LinePlot
		@constructor
		@extends AbstractPlugin
		**/
		var Plugin = (function(state) {
			var name = 'lineplot';
			Plugin.superClass.constuctor.call(this,name);
			Plugin.superClass.setContext.call(this,Config.PLUGINTYPE.CONTEXT_3D);
			Plugin.superClass.setType.call(this,Config.PLUGINTYPE.PLOT);
			/** path to plugin-template file * */
			Plugin.superClass.setTemplates.call(this,Config.absPlugins+ '/plugins_3d/lineplot/templates.js');
			Plugin.superClass.setIcon.call(this,Config.absPlugins+ '/plugins_3d/lineplot/icon.png');
			Plugin.superClass.setAccepts.call(this,{
				predecessors : [ Config.PLUGINTYPE.CONTEXT_3D ],
				successors : [ Config.PLUGINTYPE.DATA,Config.PLUGINTYPE.AXES ]
			});
			Plugin.superClass.setDescription.call(this,'Requires: [ '+this.accepts.predecessors.join(', ')+' ] Accepts: [ '+this.accepts.successors.join(', ')+' ]');
			/** ********************************** */
			/** PRIVATE VARIABLES * */
			/** ********************************** */
			var particleSizeDefault = 10;
			var opacityDefault = 1;
			var blendingDefault = false;
			var colorsDefault = true;
			var transparentDefault = false;
				var ambientDefault = '#ff0000'; // red
				var xScaleDefault = 400;
				var yScaleDefault = 400;
				var zScaleDefault = 400;


				var x_SCALE_MAX = 400;
				var x_SCALE_MIN = 0;
				var y_SCALE_MAX = 400;
				var y_SCALE_MIN = 0;
				var z_SCALE_MAX = 400;
				var z_SCALE_MIN = 0;
				if(state !== undefined){
					/*x_MAX = state.x_MAX;
					x_MIN = state.x_MIN;
					y_MAX = state.y_MAX;
					y_MIN = state.y_MIN;
					z_MAX = state.z_MAX;
					z_MIN = state.z_MIN;
					x_SCALE_MAX = state.x_SCALE_MAX;
					x_SCALE_MIN = state.x_SCALE_MIN;
					y_SCALE_MAX = state.y_SCALE_MAX;
					z_SCALE_MAX = state.z_SCALE_MAX;
					z_SCALE_MIN = state.z_SCALE_MIN;*/
				}
				/** ********************************** */
				/** PUBLIC VARIABLES * */
				/** ********************************** */

				/** ********************************** */
				/** PUBLIC METHODS * */
				/** ********************************** */
				/**
				 * Takes inserted configuration from the plugin-template and
				 * returns the parameters as JSON-config-file
				 *
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 *
				 * @return config file format:
				 *         {camera:{x:VALUE,y:VALUE,z:VALUE}}
				 */
				 this.deepCopy = function(){
				 	var privates = {
				 		/*x_MAX : x_MAX,
				 		x_MIN : x_MIN,
				 		y_MAX : y_MAX,
				 		y_MAX : y_MAX,
				 		y_MIN : y_MIN,
				 		z_MAX : z_MAX,
				 		z_MIN : z_MIN,
				 		x_SCALE_MAX : x_SCALE_MAX,
				 		x_SCALE_MIN : x_SCALE_MIN,
				 		y_SCALE_MAX : y_SCALE_MAX,
				 		y_SCALE_MIN : y_SCALE_MIN,
				 		z_SCALE_MAX : z_SCALE_MAX,
				 		z_SCALE_MIN : z_SCALE_MIN*/

				 	}
				 	return new Plugin(privates);
				 }
				 this.getConfigCallback = function(containerId) {

				 	var lineWidth = $('#' + containerId + ' #lineWidth')
				 	.val();
				 	var opacity = $('#' + containerId + ' #opacity').val();

				 	if(lineWidth === undefined || lineWidth ==""){
				 		lineWidth = 3;
				 	}
				 	if(opacity === undefined || opacity ==""){
				 		lineWidth = 1;
				 	}


				 	var xScale = $('#' + containerId + ' #xScale').val();

				 	var yScale = $('#' + containerId + ' #yScale').val();

				 	var zScale = $('#' + containerId + ' #zScale').val();

				 	var result = {
				 		lineWidth: lineWidth,
				 		opacity: opacity,
				 		scale : {
				 			'x' : xScale === "" ? xScaleDefault : xScale,
				 			'y' : yScale === "" ? yScaleDefault : yScale,
				 			'z' : zScale === "" ? zScaleDefault : zScale

				 		}

				 	};
				 	return result;

				 }
				/**
				 * Takes arguments from config and inserts them to the
				 * plugin-template
				 *
				 * @param config
				 *            plugin config file
				 * @param containerId
				 *            parent container where the plugin-template got
				 *            added
				 */
				 this.setConfigCallback = function(config, containerId) {
				 	console.log("[ line ][setConfig] ");
				 	if (config == "" || config === undefined) {
				 		config = {
				 			linewidth : '',
				 			scale : ''
				 		};
				 	}

				 	if (config.lineWidth != undefined) {
				 		$('#' + containerId + ' #lineWidth').val(
				 			config.lineWidth);
				 	} else {
				 		$('#' + containerId + ' #lineWidth').val(
				 			3);
				 		config.lineWidth = 3;
				 	}
				 	if (config.opacity != undefined) {
				 		$('#' + containerId + ' #opacity').val(
				 			config.opacity);
				 	} else {
				 		$('#' + containerId + ' #opacity').val(opacityDefault);
				 		config.opacity = 1;
				 	}

				 	if (config.scale.x != undefined) {
				 		$('#' + containerId + ' #xScale').val(config.scale.x);
				 	} else {
				 		$('#' + containerId + ' #xScale').val(xScaleDefault);
				 	}
				 	if (config.scale.y != undefined) {
				 		$('#' + containerId + ' #yScale').val(config.scale.y);
				 	} else {
				 		$('#' + containerId + ' #yScale').val(yScaleDefault);
				 	}
				 	if (config.scale.z != undefined) {
				 		$('#' + containerId + ' #zScale').val(config.scale.z);
				 	} else {
				 		$('#' + containerId + ' #zScale').val(zScaleDefault);
				 	}

					// particleSizeSlider
					$('#' + containerId ).find(' #lineWidthSlider').slider({
						orientation: "horizontal",
						range: "min",
						min: 1,
						max: 200,
						value: config.lineWidth,
						slide: function (event, ui) {
							$('#' + containerId + ' #lineWidth').val(ui.value);
						}
					});
					// opacitySlider
					$('#' + containerId ).find(' #opacitySlider').slider({
						orientation: "horizontal",
						range: "min",
						min: 0,
						max: 100,
						value: config.opacity*100,
						slide: function (event, ui) {
							$('#' + containerId + ' #opacity').val(ui.value/100);
						}
					});

				}


				this.exec = function(config, childs) {
					console.log("[ lineplot ] \t\t EXEC");
					var result = [];
					if (config === '') {
						config = {};
					}
					if (!config.hasOwnProperty('lineWidth'))
						config.lineWidth = 3;
					if (!config.hasOwnProperty('opacity'))
						config.opacity = 1;

					// set scaling
					if (config.hasOwnProperty('scale')) {
						x_SCALE_MAX = config.scale.x;
						y_SCALE_MAX = config.scale.y;
						z_SCALE_MAX = config.scale.z;
					}
					if(childs == null || childs === undefined || childs.length == 0){
						return;
					}
					var borders = {
						xMax : 'auto',
						yMax : 'auto',
						zMax : 'auto',
						xMin : 'auto',
						yMin : 'auto',
						zMin : 'auto'
					}

					/** *********************************** * */
					/** HANDLE SUCCESSOR PLUGINGS * */
					/** *********************************** * */
					var data = [];
					var colors = [];
					var heatmaps = [];
					// each dataset will be represented as a line
					var datasets = [];
					var axesSet = false;
					var axesCallback;
					var axesContext;
					var child = undefined;
					for ( var i = 0; i < childs.length; ++i) {
						child = childs[i];
						if(child !== undefined && child.pType !== undefined){
							if($.inArray(child.pType, this.accepts.successors) != -1){
								switch(child.pType){
									case Config.PLUGINTYPE.DATA:
									var tmpData = child.response.data;
									var tmpColor = child.response.colorArray
									datasets.push(child.response);
									if(child.response.heatmap !== undefined){
										heatmaps.push(child.response.heatmap);
									}
									data = data.concat(tmpData);
									colors = colors.concat(tmpColor);

									break;
									case Config.PLUGINTYPE.AXES:
									var callback = child.response.callback;
									var context = child.response.context;
									borders.xMax = child.response.rangeX;
									borders.yMax = child.response.rangeY;
									borders.zMax = child.response.rangeZ;
									axesSet = true;
									break;
								}
							}
						}else{
							console.log("pType of child plugin not set!");
						}
					}

					if(data.length == 0) return;

					/** *********************************** */
					/** GET MAX VALUES * */
					/** CHECK RANGE - auto * */

					var minMax = getMinMax(data,borders);
					borders.xMax = borders.xMax  != 'auto' ? borders.xMax : minMax.xMax;
					borders.yMax = borders.yMax  != 'auto' ? borders.yMax : minMax.yMax;
					borders.zMax = borders.zMax  != 'auto' ? borders.zMax : minMax.zMax;
					borders.xMin = borders.xMin  != 'auto' ? borders.xMin : minMax.xMin;
					borders.yMin = borders.yMin  != 'auto' ? borders.yMin : minMax.yMin;
					borders.zMin = borders.zMin  != 'auto' ? borders.zMin : minMax.zMin;

					var data_all_scaled = scale(data,borders);

					var material = new THREE.SpriteMaterial( {
						color: 0xff0000,
						program: function ( context ) {
							context.beginPath();
							context.arc( 0, 0, 0.5, 0, PI2, true );
							context.fill();
						}
					} );

					var minMax = UTILS.C3D.getMinMax(data);
					borders.xMax = borders.xMax  != 'auto' ? borders.xMax : minMax.xMax;
					borders.yMax = borders.yMax  != 'auto' ? borders.yMax : minMax.yMax;
					borders.zMax = borders.zMax  != 'auto' ? borders.zMax : minMax.zMax;
					borders.xMin = borders.xMin  != 'auto' ? borders.xMin : minMax.xMin;
					borders.yMin = borders.yMin  != 'auto' ? borders.yMin : minMax.yMin;
					borders.zMin = borders.zMin  != 'auto' ? borders.zMin : minMax.zMin;
					/** *********************************** */
					/** handle data * */
					var threeColors = [];
					var scaled_dataset, geometry, line, particle,threeColors;

					/** *********************************** */
					/** for each dataset create a line  * */
					for(var index = 0; index < datasets.length;index++){
						// scale to plot dimension

						scaled_dataset = scale(datasets[index].data,borders);

						geometry = new THREE.Geometry();
						threeColors = [];
						/** create particles from current dataset * */
						for ( var i = 0; i < scaled_dataset.length; i++) {

							particle = new THREE.Sprite( material );
							particle.position.x = scaled_dataset[ i ].x;
							particle.position.y = scaled_dataset[ i ].y;
							particle.position.z = scaled_dataset[ i ].z;
							// add node color
							threeColors.push(new THREE.Color('#'
								+ datasets[index].colorArray[i]));
							//result.push( particle );
							geometry.vertices.push( particle.position );
						}
						geometry.colors = threeColors;
						geometry.mergeVertices();

						/** create a line from particles * */
						line = new THREE.Line( geometry,
							new THREE.LineBasicMaterial( {
								color: 0xffffff,
								opacity: config.opacity,
								linewidth: config.lineWidth,
								vertexColors: THREE.VertexColors
							} )
							);

						/**  push line to result array * */
						result.push(line);
						scaled_dataset = [];
					}
					/** *********************************** */
					/** handle axes * */
					if (axesSet) {
						var axes = callback.apply(context, [ data, data_all_scaled,colors,
							x_SCALE_MAX, y_SCALE_MAX, z_SCALE_MAX, borders, minMax, heatmaps ]);
						for ( var index = 0; index < axes.length; ++index) {
							// add axes to scene
							result.push(axes[index]);
						}
					}
					/** *********************************** */
					/** handle config && plot * */
					// set color array

					return {
						pType : this.type,
						response : result
					};

				}

				/** ********************************** */
				/** PRIVATE METHODS * */
				/** ********************************** */
				var scale = function(data,borders) {

					var b2 = {
						"x_MAX":borders.xMax,
						"y_MAX":borders.yMax,
						"z_MAX":borders.zMax,
						"x_MIN":borders.xMin,
						"y_MIN":borders.yMin,
						"z_MIN":borders.zMin,
						"x_SCALE_MIN" : x_SCALE_MIN,
						"y_SCALE_MIN" : y_SCALE_MIN,
						"z_SCALE_MIN" : z_SCALE_MIN,
						"x_SCALE_MAX" : x_SCALE_MAX,
						"y_SCALE_MAX" : y_SCALE_MAX,
						"z_SCALE_MAX" : z_SCALE_MAX,
					};
					return UTILS.C3D.scaleLinearToRange(data,b2);
				}

				var getMinMax = function(data,borders) {


					var tmp_x_max, tmp_y_max, tmp_z_max, tmp_x_min, tmp_y_min, tmp_z_min;
					tmp_x_max = tmp_y_max = tmp_z_max = tmp_x_min = tmp_y_min = tmp_z_min = 0;
					for ( var index = 0; index < data.length; ++index) {

						var x = parseFloat(data[index].x);
						var y = parseFloat(data[index].y);
						var z = parseFloat(data[index].z);
						// x
						if (x >= tmp_x_max && borders.xMax == 'auto') {
							tmp_x_max = x;
						} else if (x < tmp_x_min && borders.xMin == 'auto') {
							tmp_x_min = x;
						}
						// y
						if (y >= tmp_y_max && borders.yMax == 'auto') {
							tmp_y_max = y;
						} else if (y < tmp_y_min && borders.yMin == 'auto') {
							tmp_y_min = y;
						}
						// z
						if (z >= tmp_z_max && borders.zMax == 'auto') {
							tmp_z_max = z;
						} else if (z < tmp_z_min && borders.zMin == 'auto') {
							tmp_z_min = z;
						}
					}
					var result = {};
					if (borders.xMax == 'auto'){
						result.xMax = tmp_x_max;
					}else {
						result.xMax = borders.xMax;
					}
					if (borders.yMax == 'auto'){
						result.yMax = tmp_y_max;
					}else {
						result.yMax = borders.yMax;
					}
					if (borders.zMax == 'auto'){
						result.zMax = tmp_z_max;
					}else {
						result.zMax = borders.zMax;
					}

					if (borders.xMin == 'auto'){
						result.xMin = tmp_x_min;
					}else {
						result.xMin = borders.xMin;
					}
					if (borders.yMin == 'auto'){
						result.yMin = tmp_y_min;
					}else {
						result.yMin = borders.yMin;
					}
					if (borders.zMin == 'auto'){
						result.zMin = tmp_z_min;
					}else {
						result.zMin = borders.zMin;
					}

					return result;

				}

			});
UTILS.CLASS.extend(Plugin,AbstractPlugin);
return Plugin;

});
