<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../libs/jquery-ui/development-bundle/ui/jquery-ui.custom.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AbstractPlugin.html">AbstractPlugin</a></li>
            
                <li><a href="../classes/Config.html">Config</a></li>
            
                <li><a href="../classes/Controls.html">Controls</a></li>
            
                <li><a href="../classes/Plot.html">Plot</a></li>
            
                <li><a href="../classes/Plugin 3D.html">Plugin 3D</a></li>
            
                <li><a href="../classes/Plugin Axes.html">Plugin Axes</a></li>
            
                <li><a href="../classes/Plugin BasicMaterial.html">Plugin BasicMaterial</a></li>
            
                <li><a href="../classes/Plugin CameraControl.html">Plugin CameraControl</a></li>
            
                <li><a href="../classes/Plugin Color.html">Plugin Color</a></li>
            
                <li><a href="../classes/Plugin Dataset.html">Plugin Dataset</a></li>
            
                <li><a href="../classes/Plugin File.html">Plugin File</a></li>
            
                <li><a href="../classes/Plugin Function.html">Plugin Function</a></li>
            
                <li><a href="../classes/Plugin Heatmap.html">Plugin Heatmap</a></li>
            
                <li><a href="../classes/Plugin Light.html">Plugin Light</a></li>
            
                <li><a href="../classes/Plugin LinePlot.html">Plugin LinePlot</a></li>
            
                <li><a href="../classes/Plugin Plane.html">Plugin Plane</a></li>
            
                <li><a href="../classes/Plugin ScatterPlot.html">Plugin ScatterPlot</a></li>
            
                <li><a href="../classes/Plugin SurfacePlot.html">Plugin SurfacePlot</a></li>
            
                <li><a href="../classes/Plugin WireframeMaterial.html">Plugin WireframeMaterial</a></li>
            
                <li><a href="../classes/SceneGraph.html">SceneGraph</a></li>
            
                <li><a href="../classes/Templates.html">Templates</a></li>
            
                <li><a href="../classes/Toolbox.html">Toolbox</a></li>
            
                <li><a href="../classes/UTILS.html">UTILS</a></li>
            
                <li><a href="../classes/VLib.html">VLib</a></li>
            
                <li><a href="../classes/VMediator.html">VMediator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Controls.html">Controls</a></li>
            
                <li><a href="../modules/main.html">main</a></li>
            
                <li><a href="../modules/Plot.html">Plot</a></li>
            
                <li><a href="../modules/SceneGraph.html">SceneGraph</a></li>
            
                <li><a href="../modules/Templates.html">Templates</a></li>
            
                <li><a href="../modules/Toolbox.html">Toolbox</a></li>
            
                <li><a href="../modules/VLib.html">VLib</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../libs/jquery-ui/development-bundle/ui/jquery-ui.custom.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! jQuery UI - v1.10.4 - 2014-02-01
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.button.js, jquery.ui.dialog.js, jquery.ui.effect.js, jquery.ui.effect-fade.js, jquery.ui.effect-slide.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: &quot;1.10.4&quot;,

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === &quot;number&quot; ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie &amp;&amp; (/(static|relative)/).test(this.css(&quot;position&quot;))) || (/absolute/).test(this.css(&quot;position&quot;))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,&quot;position&quot;)) &amp;&amp; (/(auto|scroll)/).test($.css(this,&quot;overflow&quot;)+$.css(this,&quot;overflow-y&quot;)+$.css(this,&quot;overflow-x&quot;));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,&quot;overflow&quot;)+$.css(this,&quot;overflow-y&quot;)+$.css(this,&quot;overflow-x&quot;));
			}).eq(0);
		}

		return (/fixed/).test(this.css(&quot;position&quot;)) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( &quot;zIndex&quot;, zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length &amp;&amp; elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( &quot;position&quot; );
				if ( position === &quot;absolute&quot; || position === &quot;relative&quot; || position === &quot;fixed&quot; ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// &lt;div style=&quot;z-index: -10;&quot;&gt;&lt;div style=&quot;z-index: 0;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
					value = parseInt( elem.css( &quot;zIndex&quot; ), 10 );
					if ( !isNaN( value ) &amp;&amp; value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = &quot;ui-id-&quot; + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( &quot;id&quot; );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( &quot;area&quot; === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot; ) {
			return false;
		}
		img = $( &quot;img[usemap=#&quot; + mapName + &quot;]&quot; )[0];
		return !!img &amp;&amp; visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		&quot;a&quot; === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &amp;&amp;
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &amp;&amp;
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, &quot;visibility&quot; ) === &quot;hidden&quot;;
		}).length;
}

$.extend( $.expr[ &quot;:&quot; ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery &lt;1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, &quot;tabindex&quot; ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, &quot;tabindex&quot; ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex &gt;= 0 ) &amp;&amp; focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery &lt;1.8
if ( !$( &quot;&lt;a&gt;&quot; ).outerWidth( 1 ).jquery ) {
	$.each( [ &quot;Width&quot;, &quot;Height&quot; ], function( i, name ) {
		var side = name === &quot;Width&quot; ? [ &quot;Left&quot;, &quot;Right&quot; ] : [ &quot;Top&quot;, &quot;Bottom&quot; ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, &quot;padding&quot; + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, &quot;border&quot; + this + &quot;Width&quot; ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, &quot;margin&quot; + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ &quot;inner&quot; + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ &quot;inner&quot; + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + &quot;px&quot; );
			});
		};

		$.fn[ &quot;outer&quot; + name] = function( size, margin ) {
			if ( typeof size !== &quot;number&quot; ) {
				return orig[ &quot;outer&quot; + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + &quot;px&quot; );
			});
		};
	});
}

// support: jQuery &lt;1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( &quot;&lt;a&gt;&quot; ).data( &quot;a-b&quot;, &quot;a&quot; ).removeData( &quot;a-b&quot; ).data( &quot;a-b&quot; ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = &quot;onselectstart&quot; in document.createElement( &quot;div&quot; );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? &quot;selectstart&quot; : &quot;mousedown&quot; ) +
			&quot;.ui-disableSelection&quot;, function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( &quot;.ui-disableSelection&quot; );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i &lt; set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( &quot;overflow&quot; ) === &quot;hidden&quot;) {
			return false;
		}

		var scroll = ( a &amp;&amp; a === &quot;left&quot; ) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;,
			has = false;

		if ( el[ scroll ] &gt; 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn&#x27;t have the scroll set, see if it&#x27;s possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] &gt; 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( &quot;remove&quot; );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( &quot;.&quot; )[ 0 ];

	name = name.split( &quot;.&quot; )[ 1 ];
	fullName = namespace + &quot;-&quot; + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ &quot;:&quot; ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without &quot;new&quot; keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use &quot;new&quot; keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we&#x27;ll modify the options hash on the prototype that we&#x27;re
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don&#x27;t prefix for widgets that aren&#x27;t DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We&#x27;re essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + &quot;.&quot; + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex &lt; inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) &amp;&amp; value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don&#x27;t extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === &quot;string&quot;,
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall &amp;&amp; args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( &quot;cannot call methods on &quot; + name + &quot; prior to initialization; &quot; +
						&quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot; );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === &quot;_&quot; ) {
					return $.error( &quot;no such method &#x27;&quot; + options + &quot;&#x27; for &quot; + name + &quot; widget instance&quot; );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance &amp;&amp; methodValue !== undefined ) {
					returnValue = methodValue &amp;&amp; methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: &quot;widget&quot;,
	widgetEventPrefix: &quot;&quot;,
	defaultElement: &quot;&lt;div&gt;&quot;,
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = &quot;.&quot; + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( &quot;create&quot;, null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery &lt;1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( &quot;aria-disabled&quot; )
			.removeClass(
				this.widgetFullName + &quot;-disabled &quot; +
				&quot;ui-state-disabled&quot; );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( &quot;ui-state-hover&quot; );
		this.focusable.removeClass( &quot;ui-state-focus&quot; );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don&#x27;t return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === &quot;string&quot; ) {
			// handle nested keys, e.g., &quot;foo.bar&quot; =&gt; { foo: { bar: ___ } }
			options = {};
			parts = key.split( &quot;.&quot; );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i &lt; parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === &quot;disabled&quot; ) {
			this.widget()
				.toggleClass( this.widgetFullName + &quot;-disabled ui-state-disabled&quot;, !!value )
				.attr( &quot;aria-disabled&quot;, value );
			this.hoverable.removeClass( &quot;ui-state-hover&quot; );
			this.focusable.removeClass( &quot;ui-state-focus&quot; );
		}

		return this;
	},

	enable: function() {
		return this._setOption( &quot;disabled&quot;, false );
	},
	disable: function() {
		return this._setOption( &quot;disabled&quot;, true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== &quot;boolean&quot; ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &amp;&amp;
						( instance.options.disabled === true ||
							$( this ).hasClass( &quot;ui-state-disabled&quot; ) ) ) {
					return;
				}
				return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== &quot;string&quot; ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || &quot;&quot;).split( &quot; &quot; ).join( this.eventNamespace + &quot; &quot; ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-hover&quot; );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-hover&quot; );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-focus&quot; );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-focus&quot; );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &amp;&amp;
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: &quot;fadeIn&quot;, hide: &quot;fadeOut&quot; }, function( method, defaultEffect ) {
	$.Widget.prototype[ &quot;_&quot; + method ] = function( element, options, callback ) {
		if ( typeof options === &quot;string&quot; ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === &quot;number&quot; ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === &quot;number&quot; ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions &amp;&amp; $.effects &amp;&amp; $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method &amp;&amp; element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget(&quot;ui.mouse&quot;, {
	version: &quot;1.10.4&quot;,
	options: {
		cancel: &quot;input,textarea,button,select,option&quot;,
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind(&quot;mousedown.&quot;+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind(&quot;click.&quot;+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + &quot;.preventClickEvent&quot;)) {
					$.removeData(event.target, that.widgetName + &quot;.preventClickEvent&quot;);
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn&#x27;t mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind(&quot;.&quot;+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind(&quot;mousemove.&quot;+this.widgetName, this._mouseMoveDelegate)
				.unbind(&quot;mouseup.&quot;+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don&#x27;t let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted &amp;&amp; this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === &quot;string&quot; &amp;&amp; event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko &amp; Opera)
		if (true === $.data(event.target, this.widgetName + &quot;.preventClickEvent&quot;)) {
			$.removeData(event.target, this.widgetName + &quot;.preventClickEvent&quot;);
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind(&quot;mousemove.&quot;+this.widgetName, this._mouseMoveDelegate)
			.bind(&quot;mouseup.&quot;+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie &amp;&amp; ( !document.documentMode || document.documentMode &lt; 9 ) &amp;&amp; !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind(&quot;mousemove.&quot;+this.widgetName, this._mouseMoveDelegate)
			.unbind(&quot;mouseup.&quot;+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + &quot;.preventClickEvent&quot;, true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) &gt;= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( &quot;&lt;div style=&#x27;display:block;position:absolute;width:50px;height:50px;overflow:hidden;&#x27;&gt;&lt;div style=&#x27;height:100px;width:auto;&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot; ),
			innerDiv = div.children()[0];

		$( &quot;body&quot; ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( &quot;overflow&quot;, &quot;scroll&quot; );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? &quot;&quot; :
				within.element.css( &quot;overflow-x&quot; ),
			overflowY = within.isWindow || within.isDocument ? &quot;&quot; :
				within.element.css( &quot;overflow-y&quot; ),
			hasOverflowX = overflowX === &quot;scroll&quot; ||
				( overflowX === &quot;auto&quot; &amp;&amp; within.width &lt; within.element[0].scrollWidth ),
			hasOverflowY = overflowY === &quot;scroll&quot; ||
				( overflowY === &quot;auto&quot; &amp;&amp; within.height &lt; within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] &amp;&amp; withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don&#x27;t want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || &quot;flip&quot; ).split( &quot; &quot; ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = &quot;left top&quot;;
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ &quot;my&quot;, &quot;at&quot; ], function() {
		var pos = ( options[ this ] || &quot;&quot; ).split( &quot; &quot; ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ &quot;center&quot; ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ &quot;center&quot; ].concat( pos ) :
					[ &quot;center&quot;, &quot;center&quot; ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : &quot;center&quot;;
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : &quot;center&quot;;

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === &quot;right&quot; ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === &quot;center&quot; ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === &quot;bottom&quot; ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === &quot;center&quot; ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, &quot;marginLeft&quot; ),
			marginTop = parseCss( this, &quot;marginTop&quot; ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, &quot;marginRight&quot; ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, &quot;marginBottom&quot; ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === &quot;right&quot; ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === &quot;center&quot; ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === &quot;bottom&quot; ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === &quot;center&quot; ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn&#x27;t support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right &lt; 0 ? &quot;left&quot; : left &gt; 0 ? &quot;right&quot; : &quot;center&quot;,
						vertical: bottom &lt; 0 ? &quot;top&quot; : top &gt; 0 ? &quot;bottom&quot; : &quot;middle&quot;
					};
				if ( targetWidth &lt; elemWidth &amp;&amp; abs( left + right ) &lt; targetWidth ) {
					feedback.horizontal = &quot;center&quot;;
				}
				if ( targetHeight &lt; elemHeight &amp;&amp; abs( top + bottom ) &lt; targetHeight ) {
					feedback.vertical = &quot;middle&quot;;
				}
				if ( max( abs( left ), abs( right ) ) &gt; max( abs( top ), abs( bottom ) ) ) {
					feedback.important = &quot;horizontal&quot;;
				} else {
					feedback.important = &quot;vertical&quot;;
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth &gt; outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft &gt; 0 &amp;&amp; overRight &lt;= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight &gt; 0 &amp;&amp; overLeft &lt;= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft &gt; overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -&gt; align with left edge
			} else if ( overLeft &gt; 0 ) {
				position.left += overLeft;
			// too far right -&gt; align with right edge
			} else if ( overRight &gt; 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight &gt; outerHeight ) {
				// element is initially over the top of within
				if ( overTop &gt; 0 &amp;&amp; overBottom &lt;= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom &gt; 0 &amp;&amp; overTop &lt;= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop &gt; overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -&gt; align with top
			} else if ( overTop &gt; 0 ) {
				position.top += overTop;
			// too far down -&gt; align with bottom edge
			} else if ( overBottom &gt; 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === &quot;left&quot; ?
					-data.elemWidth :
					data.my[ 0 ] === &quot;right&quot; ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === &quot;left&quot; ?
					data.targetWidth :
					data.at[ 0 ] === &quot;right&quot; ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft &lt; 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight &lt; 0 || newOverRight &lt; abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight &gt; 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft &gt; 0 || abs( newOverLeft ) &lt; overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === &quot;top&quot;,
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === &quot;bottom&quot; ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === &quot;top&quot; ?
					data.targetHeight :
					data.at[ 1 ] === &quot;bottom&quot; ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop &lt; 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overTop &amp;&amp; ( newOverBottom &lt; 0 || newOverBottom &lt; abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom &gt; 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overBottom &amp;&amp; ( newOverTop &gt; 0 || abs( newOverTop ) &lt; overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( &quot;body&quot; )[ 0 ],
		div = document.createElement( &quot;div&quot; );

	//Create a &quot;fake body&quot; for testing based on method used in jQuery.support
	testElement = document.createElement( body ? &quot;div&quot; : &quot;body&quot; );
	testElementStyle = {
		visibility: &quot;hidden&quot;,
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: &quot;none&quot;
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: &quot;absolute&quot;,
			left: &quot;-1000px&quot;,
			top: &quot;-1000px&quot;
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = &quot;position: absolute; left: 10.7432222px;&quot;;

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft &gt; 10 &amp;&amp; offsetLeft &lt; 11;

	testElement.innerHTML = &quot;&quot;;
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );
(function( $, undefined ) {

$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	version: &quot;1.10.4&quot;,
	widgetEventPrefix: &quot;drag&quot;,
	options: {
		addClasses: true,
		appendTo: &quot;parent&quot;,
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: &quot;default&quot;,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: &quot;both&quot;,
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === &quot;original&quot; &amp;&amp; !(/^(?:r|a|f)/).test(this.element.css(&quot;position&quot;))) {
			this.element[0].style.position = &quot;relative&quot;;
		}
		if (this.options.addClasses){
			this.element.addClass(&quot;ui-draggable&quot;);
		}
		if (this.options.disabled){
			this.element.addClass(&quot;ui-draggable-disabled&quot;);
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( &quot;ui-draggable ui-draggable-dragging ui-draggable-disabled&quot; );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(&quot;.ui-resizable-handle&quot;).length &gt; 0) {
			return false;
		}

		//Quit if we&#x27;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
			$(&quot;&lt;div class=&#x27;ui-draggable-iframeFix&#x27; style=&#x27;background: #fff;&#x27;&gt;&lt;/div&gt;&quot;)
			.css({
				width: this.offsetWidth+&quot;px&quot;, height: this.offsetHeight+&quot;px&quot;,
				position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
			})
			.css($(this).offset())
			.appendTo(&quot;body&quot;);
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper&#x27;s css position
		this.cssPosition = this.helper.css( &quot;position&quot; );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( &quot;position&quot; );

		//The element&#x27;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if &quot;cursorAt&quot; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === &quot;fixed&quot; ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger(&quot;drag&quot;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== &quot;y&quot;) {
			this.helper[0].style.left = this.position.left+&quot;px&quot;;
		}
		if(!this.options.axis || this.options.axis !== &quot;x&quot;) {
			this.helper[0].style.top = this.position.top+&quot;px&quot;;
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don&#x27;t bother to continue (see #8269)
		if ( this.options.helper === &quot;original&quot; &amp;&amp; !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === &quot;invalid&quot; &amp;&amp; !dropped) || (this.options.revert === &quot;valid&quot; &amp;&amp; dropped) || this.options.revert === true || ($.isFunction(this.options.revert) &amp;&amp; this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger(&quot;stop&quot;, event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$(&quot;div.ui-draggable-iframeFix&quot;).each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === &quot;clone&quot; ? this.element.clone().removeAttr(&quot;id&quot;) : this.element);

		if(!helper.parents(&quot;body&quot;).length) {
			helper.appendTo((o.appendTo === &quot;parent&quot; ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] &amp;&amp; !(/(fixed|absolute)/).test(helper.css(&quot;position&quot;))) {
			helper.css(&quot;position&quot;, &quot;absolute&quot;);
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === &quot;string&quot;) {
			obj = obj.split(&quot; &quot;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&quot;left&quot; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&quot;right&quot; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&quot;top&quot; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&quot;bottom&quot; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === &quot;absolute&quot; &amp;&amp; this.scrollParent[0] !== document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() === &quot;html&quot; &amp;&amp; $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === &quot;relative&quot;) {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === &quot;window&quot; ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === &quot;document&quot;) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === &quot;parent&quot; ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( &quot;overflow&quot; ) !== &quot;hidden&quot;;

		this.containment = [
			( parseInt( c.css( &quot;borderLeftWidth&quot; ), 10 ) || 0 ) + ( parseInt( c.css( &quot;paddingLeft&quot; ), 10 ) || 0 ),
			( parseInt( c.css( &quot;borderTopWidth&quot; ), 10 ) || 0 ) + ( parseInt( c.css( &quot;paddingTop&quot; ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( &quot;borderRightWidth&quot; ), 10 ) || 0 ) - ( parseInt( c.css( &quot;paddingRight&quot; ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( &quot;borderBottomWidth&quot; ), 10 ) || 0 ) - ( parseInt( c.css( &quot;paddingBottom&quot; ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === &quot;absolute&quot; ? 1 : -1,
			scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp; !( this.scrollParent[ 0 ] !== document &amp;&amp; $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent&#x27;s offset without borders (offset + border)
				( ( this.cssPosition === &quot;fixed&quot; ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent&#x27;s offset without borders (offset + border)
				( ( this.cssPosition === &quot;fixed&quot; ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === &quot;absolute&quot; &amp;&amp; !( this.scrollParent[ 0 ] !== document &amp;&amp; $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won&#x27;t check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left &lt; containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top &lt; containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left &gt; containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top &gt; containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top &gt;= containment[1] || top - this.offset.click.top &gt; containment[3]) ? top : ((top - this.offset.click.top &gt;= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left &gt;= containment[0] || left - this.offset.click.left &gt; containment[2]) ? left : ((left - this.offset.click.left &gt;= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent&#x27;s offset without borders (offset + border)
				( this.cssPosition === &quot;fixed&quot; ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent&#x27;s offset without borders (offset + border)
				( this.cssPosition === &quot;fixed&quot; ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if(this.helper[0] !== this.element[0] &amp;&amp; !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === &quot;drag&quot;) {
			this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function(event, ui) {

		var inst = $(this).data(&quot;ui-draggable&quot;), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, &quot;ui-sortable&quot;);
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable&#x27;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#x27;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data(&quot;ui-draggable&quot;),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don&#x27;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &quot;valid/invalid&quot;
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === &quot;original&quot;) {
					this.instance.currentItem.css({ top: &quot;auto&quot;, left: &quot;auto&quot; });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;ui-draggable&quot;), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable&#x27;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &amp;&amp;
						this.instance._intersectsWith(this.instance.containerCache) &amp;&amp;
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#x27;t create a new one)
					this.instance.currentItem = $(that).clone().removeAttr(&quot;id&quot;).appendTo(this.instance.element).data(&quot;ui-sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn&#x27;t intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn&#x27;t remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger(&quot;out&quot;, event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#x27;s original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function() {
		var t = $(&quot;body&quot;), o = $(this).data(&quot;ui-draggable&quot;).options;
		if (t.css(&quot;cursor&quot;)) {
			o._cursor = t.css(&quot;cursor&quot;);
		}
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function() {
		var o = $(this).data(&quot;ui-draggable&quot;).options;
		if (o._cursor) {
			$(&quot;body&quot;).css(&quot;cursor&quot;, o._cursor);
		}
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;ui-draggable&quot;).options;
		if(t.css(&quot;opacity&quot;)) {
			o._opacity = t.css(&quot;opacity&quot;);
		}
		t.css(&quot;opacity&quot;, o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;ui-draggable&quot;).options;
		if(o._opacity) {
			$(ui.helper).css(&quot;opacity&quot;, o._opacity);
		}
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function() {
		var i = $(this).data(&quot;ui-draggable&quot;);
		if(i.scrollParent[0] !== document &amp;&amp; i.scrollParent[0].tagName !== &quot;HTML&quot;) {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data(&quot;ui-draggable&quot;), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document &amp;&amp; i.scrollParent[0].tagName !== &quot;HTML&quot;) {

			if(!o.axis || o.axis !== &quot;x&quot;) {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== &quot;y&quot;) {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== &quot;x&quot;) {
				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== &quot;y&quot;) {
				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function() {

		var i = $(this).data(&quot;ui-draggable&quot;),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || &quot;:data(ui-draggable)&quot; ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data(&quot;ui-draggable&quot;),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i &gt;= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 &lt; l - d || x1 &gt; r + d || y2 &lt; t - d || y1 &gt; b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== &quot;inner&quot;) {
				ts = Math.abs(t - y2) &lt;= d;
				bs = Math.abs(b - y1) &lt;= d;
				ls = Math.abs(l - x2) &lt;= d;
				rs = Math.abs(r - x1) &lt;= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== &quot;outer&quot;) {
				ts = Math.abs(t - y1) &lt;= d;
				bs = Math.abs(b - y2) &lt;= d;
				ls = Math.abs(l - x1) &lt;= d;
				rs = Math.abs(r - x2) &lt;= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function() {
		var min,
			o = this.data(&quot;ui-draggable&quot;).options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css(&quot;zIndex&quot;),10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css(&quot;zIndex&quot;), 10) || 0;
		$(group).each(function(i) {
			$(this).css(&quot;zIndex&quot;, min + i);
		});
		this.css(&quot;zIndex&quot;, (min + group.length));
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;ui-draggable&quot;).options;
		if(t.css(&quot;zIndex&quot;)) {
			o._zIndex = t.css(&quot;zIndex&quot;);
		}
		t.css(&quot;zIndex&quot;, o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;ui-draggable&quot;).options;
		if(o._zIndex) {
			$(ui.helper).css(&quot;zIndex&quot;, o._zIndex);
		}
	}
});

})(jQuery);
(function( $, undefined ) {

function isOverAxis( x, reference, size ) {
	return ( x &gt; reference ) &amp;&amp; ( x &lt; ( reference + size ) );
}

$.widget(&quot;ui.droppable&quot;, {
	version: &quot;1.10.4&quot;,
	widgetEventPrefix: &quot;drop&quot;,
	options: {
		accept: &quot;*&quot;,
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable&#x27;s proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable&#x27;s proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses &amp;&amp; this.element.addClass(&quot;ui-droppable&quot;));

	},

	_destroy: function() {
		var i = 0,
			drop = $.ui.ddmanager.droppables[this.options.scope];

		for ( ; i &lt; drop.length; i++ ) {
			if ( drop[i] === this ) {
				drop.splice(i, 1);
			}
		}

		this.element.removeClass(&quot;ui-droppable ui-droppable-disabled&quot;);
	},

	_setOption: function(key, value) {

		if(key === &quot;accept&quot;) {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.addClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger(&quot;activate&quot;, event, this.ui(draggable));
		}
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.removeClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger(&quot;deactivate&quot;, event, this.ui(draggable));
		}
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.addClass(this.options.hoverClass);
			}
			this._trigger(&quot;over&quot;, event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger(&quot;out&quot;, event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return false;
		}

		this.element.find(&quot;:data(ui-droppable)&quot;).not(&quot;.ui-draggable-dragging&quot;).each(function() {
			var inst = $.data(this, &quot;ui-droppable&quot;);
			if(
				inst.options.greedy &amp;&amp;
				!inst.options.disabled &amp;&amp;
				inst.options.scope === draggable.options.scope &amp;&amp;
				inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &amp;&amp;
				$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) {
			return false;
		}

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) {
				this.element.removeClass(this.options.activeClass);
			}
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger(&quot;drop&quot;, event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) {
		return false;
	}

	var draggableLeft, draggableTop,
		x1 = (draggable.positionAbs || draggable.position.absolute).left,
		y1 = (draggable.positionAbs || draggable.position.absolute).top,
		x2 = x1 + draggable.helperProportions.width,
		y2 = y1 + draggable.helperProportions.height,
		l = droppable.offset.left,
		t = droppable.offset.top,
		r = l + droppable.proportions().width,
		b = t + droppable.proportions().height;

	switch (toleranceMode) {
		case &quot;fit&quot;:
			return (l &lt;= x1 &amp;&amp; x2 &lt;= r &amp;&amp; t &lt;= y1 &amp;&amp; y2 &lt;= b);
		case &quot;intersect&quot;:
			return (l &lt; x1 + (draggable.helperProportions.width / 2) &amp;&amp; // Right Half
				x2 - (draggable.helperProportions.width / 2) &lt; r &amp;&amp; // Left Half
				t &lt; y1 + (draggable.helperProportions.height / 2) &amp;&amp; // Bottom Half
				y2 - (draggable.helperProportions.height / 2) &lt; b ); // Top Half
		case &quot;pointer&quot;:
			draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
			draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
			return isOverAxis( draggableTop, t, droppable.proportions().height ) &amp;&amp; isOverAxis( draggableLeft, l, droppable.proportions().width );
		case &quot;touch&quot;:
			return (
				(y1 &gt;= t &amp;&amp; y1 &lt;= b) ||	// Top edge touching
				(y2 &gt;= t &amp;&amp; y2 &lt;= b) ||	// Bottom edge touching
				(y1 &lt; t &amp;&amp; y2 &gt; b)		// Surrounded vertically
			) &amp;&amp; (
				(x1 &gt;= l &amp;&amp; x1 &lt;= r) ||	// Left edge touching
				(x2 &gt;= l &amp;&amp; x2 &lt;= r) ||	// Right edge touching
				(x1 &lt; l &amp;&amp; x2 &gt; r)		// Surrounded horizontally
			);
		default:
			return false;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { &quot;default&quot;: [] },
	prepareOffsets: function(t, event) {

		var i, j,
			m = $.ui.ddmanager.droppables[t.options.scope] || [],
			type = event ? event.type : null, // workaround for #2317
			list = (t.currentItem || t.element).find(&quot;:data(ui-droppable)&quot;).addBack();

		droppablesLoop: for (i = 0; i &lt; m.length; i++) {

			//No disabled and non-accepted
			if(m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
				continue;
			}

			// Filter out elements in the current dragged item
			for (j=0; j &lt; list.length; j++) {
				if(list[j] === m[i].element[0]) {
					m[i].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[i].visible = m[i].element.css(&quot;display&quot;) !== &quot;none&quot;;
			if(!m[i].visible) {
				continue;
			}

			//Activate the droppable if used directly from draggables
			if(type === &quot;mousedown&quot;) {
				m[i]._activate.call(m[i], event);
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

			if(!this.options) {
				return;
			}
			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; $.ui.intersect(draggable, this, this.options.tolerance)) {
				dropped = this._drop.call(this, event) || dropped;
			}

			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( &quot;body&quot; ).bind( &quot;scroll.droppable&quot;, function() {
			if( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) {
			$.ui.ddmanager.prepareOffsets(draggable, event);
		}

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect(draggable, this, this.options.tolerance),
				c = !intersects &amp;&amp; this.isover ? &quot;isout&quot; : (intersects &amp;&amp; !this.isover ? &quot;isover&quot; : null);
			if(!c) {
				return;
			}

			if (this.options.greedy) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents(&quot;:data(ui-droppable)&quot;).filter(function () {
					return $.data(this, &quot;ui-droppable&quot;).options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], &quot;ui-droppable&quot;);
					parentInstance.greedyChild = (c === &quot;isover&quot;);
				}
			}

			// we just moved into a greedy child
			if (parentInstance &amp;&amp; c === &quot;isover&quot;) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = true;
			this[c === &quot;isout&quot; ? &quot;isover&quot; : &quot;isout&quot;] = false;
			this[c === &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance &amp;&amp; c === &quot;isout&quot;) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( &quot;body&quot; ).unbind( &quot;scroll.droppable&quot; );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

})(jQuery);
(function( $, undefined ) {

function num(v) {
	return parseInt(v, 10) || 0;
}

function isNumber(value) {
	return !isNaN(parseInt(value, 10));
}

$.widget(&quot;ui.resizable&quot;, $.ui.mouse, {
	version: &quot;1.10.4&quot;,
	widgetEventPrefix: &quot;resize&quot;,
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: &quot;slow&quot;,
		animateEasing: &quot;swing&quot;,
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: &quot;e,s,se&quot;,
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},
	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass(&quot;ui-resizable&quot;);

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || &quot;ui-resizable-helper&quot; : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$(&quot;&lt;div class=&#x27;ui-wrapper&#x27; style=&#x27;overflow: hidden;&#x27;&gt;&lt;/div&gt;&quot;).css({
					position: this.element.css(&quot;position&quot;),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css(&quot;top&quot;),
					left: this.element.css(&quot;left&quot;)
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				&quot;ui-resizable&quot;, this.element.data(&quot;ui-resizable&quot;)
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css(&quot;marginLeft&quot;), marginTop: this.originalElement.css(&quot;marginTop&quot;), marginRight: this.originalElement.css(&quot;marginRight&quot;), marginBottom: this.originalElement.css(&quot;marginBottom&quot;) });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css(&quot;resize&quot;);
			this.originalElement.css(&quot;resize&quot;, &quot;none&quot;);

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: &quot;static&quot;, zoom: 1, display: &quot;block&quot; }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css(&quot;margin&quot;) });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(&quot;.ui-resizable-handle&quot;, this.element).length ? &quot;e,s,se&quot; : { n: &quot;.ui-resizable-n&quot;, e: &quot;.ui-resizable-e&quot;, s: &quot;.ui-resizable-s&quot;, w: &quot;.ui-resizable-w&quot;, se: &quot;.ui-resizable-se&quot;, sw: &quot;.ui-resizable-sw&quot;, ne: &quot;.ui-resizable-ne&quot;, nw: &quot;.ui-resizable-nw&quot; });
		if(this.handles.constructor === String) {

			if ( this.handles === &quot;all&quot;) {
				this.handles = &quot;n,e,s,w,se,sw,ne,nw&quot;;
			}

			n = this.handles.split(&quot;,&quot;);
			this.handles = {};

			for(i = 0; i &lt; n.length; i++) {

				handle = $.trim(n[i]);
				hname = &quot;ui-resizable-&quot;+handle;
				axis = $(&quot;&lt;div class=&#x27;ui-resizable-handle &quot; + hname + &quot;&#x27;&gt;&lt;/div&gt;&quot;);

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What&#x27;s going on here?
				if (&quot;se&quot; === handle) {
					axis.addClass(&quot;ui-icon ui-icon-gripsmall-diagonal-se&quot;);
				}

				//Insert into internal handles object and append to element
				this.handles[handle] = &quot;.ui-resizable-&quot;+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = $(this.handles[i], this.element).show();
				}

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper &amp;&amp; this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					padPos = [ &quot;padding&quot;,
						/ne|nw|n/.test(i) ? &quot;Top&quot; :
						/se|sw|s/.test(i) ? &quot;Bottom&quot; :
						/^e$/.test(i) ? &quot;Right&quot; : &quot;Left&quot; ].join(&quot;&quot;);

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What&#x27;s that good for? There&#x27;s not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(&quot;.ui-resizable-handle&quot;, this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				//Axis, default = se
				that.axis = axis &amp;&amp; axis[1] ? axis[1] : &quot;se&quot;;
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass(&quot;ui-resizable-autohide&quot;)
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass(&quot;ui-resizable-autohide&quot;);
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass(&quot;ui-resizable-autohide&quot;);
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass(&quot;ui-resizable ui-resizable-disabled ui-resizable-resizing&quot;)
					.removeData(&quot;resizable&quot;).removeData(&quot;ui-resizable&quot;).unbind(&quot;.resizable&quot;).find(&quot;.ui-resizable-handle&quot;).remove();
			};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css(&quot;position&quot;),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css(&quot;top&quot;),
				left: wrapper.css(&quot;left&quot;)
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css(&quot;resize&quot;, this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled &amp;&amp; capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			iniPos = this.element.position(),
			el = this.element;

		this.resizing = true;

		// bugfix for http://dev.jquery.com/ticket/1749
		if ( (/absolute/).test( el.css(&quot;position&quot;) ) ) {
			el.css({ position: &quot;absolute&quot;, top: el.css(&quot;top&quot;), left: el.css(&quot;left&quot;) });
		} else if (el.is(&quot;.ui-draggable&quot;)) {
			el.css({ position: &quot;absolute&quot;, top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		curleft = num(this.helper.css(&quot;left&quot;));
		curtop = num(this.helper.css(&quot;top&quot;));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio === &quot;number&quot;) ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(&quot;.ui-resizable-&quot; + this.axis).css(&quot;cursor&quot;);
		$(&quot;body&quot;).css(&quot;cursor&quot;, cursor === &quot;auto&quot; ? this.axis + &quot;-resize&quot; : cursor);

		el.addClass(&quot;ui-resizable-resizing&quot;);
		this._propagate(&quot;start&quot;, event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			prevTop = this.position.top,
			prevLeft = this.position.left,
			prevWidth = this.size.width,
			prevHeight = this.size.height,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		if (!trigger) {
			return false;
		}

		// Calculate the attrs that will be change
		data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		// plugins callbacks need to be called first
		this._propagate(&quot;resize&quot;, event);

		if (this.position.top !== prevTop) {
			props.top = this.position.top + &quot;px&quot;;
		}
		if (this.position.left !== prevLeft) {
			props.left = this.position.left + &quot;px&quot;;
		}
		if (this.size.width !== prevWidth) {
			props.width = this.size.width + &quot;px&quot;;
		}
		if (this.size.height !== prevHeight) {
			props.height = this.size.height + &quot;px&quot;;
		}
		el.css(props);

		if (!this._helper &amp;&amp; this._proportionallyResizeElements.length) {
			this._proportionallyResize();
		}

		// Call the user callback if the element was resized
		if ( ! $.isEmptyObject(props) ) {
			this._trigger(&quot;resize&quot;, event, this.ui());
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length &amp;&amp; (/textarea/i).test(pr[0].nodeName);
			soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &quot;left&quot;) /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css(&quot;left&quot;), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css(&quot;top&quot;), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper &amp;&amp; !o.animate) {
				this._proportionallyResize();
			}
		}

		$(&quot;body&quot;).css(&quot;cursor&quot;, &quot;auto&quot;);

		this.element.removeClass(&quot;ui-resizable-resizing&quot;);

		this._propagate(&quot;stop&quot;, event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the &quot;projected&quot; size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth &gt; b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight &gt; b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth &lt; b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight &lt; b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === &quot;sw&quot;) {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === &quot;nw&quot;) {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth &lt; data.width), ismaxh = isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight &lt; data.height),
			isminw = isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt; data.width), isminh = isNumber(data.height) &amp;&amp; o.minHeight &amp;&amp; (o.minHeight &gt; data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw &amp;&amp; cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw &amp;&amp; cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh &amp;&amp; ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh &amp;&amp; ch) {
			data.top = dh - o.maxHeight;
		}

		// fixing jump error on top/left - bug #2330
		if (!data.width &amp;&amp; !data.height &amp;&amp; !data.left &amp;&amp; data.top) {
			data.top = null;
		} else if (!data.width &amp;&amp; !data.height &amp;&amp; !data.top &amp;&amp; data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i &lt; this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css(&quot;borderTopWidth&quot;), prel.css(&quot;borderRightWidth&quot;), prel.css(&quot;borderBottomWidth&quot;), prel.css(&quot;borderLeftWidth&quot;)];
				paddings = [prel.css(&quot;paddingTop&quot;), prel.css(&quot;paddingRight&quot;), prel.css(&quot;paddingBottom&quot;), prel.css(&quot;paddingLeft&quot;)];

				for ( j = 0; j &lt; borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $(&quot;&lt;div style=&#x27;overflow:hidden;&#x27;&gt;&lt;/div&gt;&quot;);

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: &quot;absolute&quot;,
				left: this.elementOffset.left +&quot;px&quot;,
				top: this.elementOffset.top +&quot;px&quot;,
				zIndex: ++o.zIndex //TODO: Don&#x27;t modify option
			});

			this.helper
				.appendTo(&quot;body&quot;)
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== &quot;resize&quot; &amp;&amp; this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {

	stop: function( event ) {
		var that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length &amp;&amp; (/textarea/i).test(pr[0].nodeName),
			soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &quot;left&quot;) /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css(&quot;left&quot;), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css(&quot;top&quot;), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top &amp;&amp; left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css(&quot;width&quot;), 10),
						height: parseInt(that.element.css(&quot;height&quot;), 10),
						top: parseInt(that.element.css(&quot;top&quot;), 10),
						left: parseInt(that.element.css(&quot;left&quot;), 10)
					};

					if (pr &amp;&amp; pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate(&quot;resize&quot;, event);

				}
			}
		);
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

		if (!ce) {
			return;
		}

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc === document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i&#x27;m a node, so compute top, left, right, bottom
		else {
			element = $(ce);
			p = [];
			$([ &quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot; ]).each(function(i, name) { p[i] = num(element.css(&quot;padding&quot; + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ($.ui.hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw );
			height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			co = that.containerOffset, cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] !== document &amp;&amp; (/static/).test(ce.css(&quot;position&quot;))) {
			cop = co;
		}

		if (cp.left &lt; (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top &lt; (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
		hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		isParent = that.containerElement.get(0) === that.element.parent().get(0);
		isOffsetRelative = /relative|absolute/.test(that.containerElement.css(&quot;position&quot;));

		if ( isParent &amp;&amp; isOffsetRelative ) {
			woset -= Math.abs( that.parentData.left );
		}

		if (woset + that.size.width &gt;= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
		}

		if (hoset + that.size.height &gt;= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
		}
	},

	stop: function(){
		var that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $(that.helper),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (/relative/).test(ce.css(&quot;position&quot;))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (/static/).test(ce.css(&quot;position&quot;))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {

	start: function () {
		var that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data(&quot;ui-resizable-alsoresize&quot;, {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css(&quot;left&quot;), 10), top: parseInt(el.css(&quot;top&quot;), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === &quot;object&quot; &amp;&amp; !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data(&quot;ui-resizable-alsoresize&quot;), style = {},
						css = c &amp;&amp; c.length ? c : el.parents(ui.originalElement[0]).length ? [&quot;width&quot;, &quot;height&quot;] : [&quot;width&quot;, &quot;height&quot;, &quot;top&quot;, &quot;left&quot;];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum &amp;&amp; sum &gt;= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === &quot;object&quot; &amp;&amp; !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData(&quot;resizable-alsoresize&quot;);
	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {

	start: function() {

		var that = $(this).data(&quot;ui-resizable&quot;), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: &quot;block&quot;, position: &quot;relative&quot;, height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass(&quot;ui-resizable-ghost&quot;)
			.addClass(typeof o.ghost === &quot;string&quot; ? o.ghost : &quot;&quot;);

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).data(&quot;ui-resizable&quot;);
		if (that.ghost) {
			that.ghost.css({ position: &quot;relative&quot;, height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).data(&quot;ui-resizable&quot;);
		if (that.ghost &amp;&amp; that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {

	resize: function() {
		var that = $(this).data(&quot;ui-resizable&quot;),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === &quot;number&quot; ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth &amp;&amp; (o.maxWidth &lt; newWidth),
			isMaxHeight = o.maxHeight &amp;&amp; (o.maxHeight &lt; newHeight),
			isMinWidth = o.minWidth &amp;&amp; (o.minWidth &gt; newWidth),
			isMinHeight = o.minHeight &amp;&amp; (o.minHeight &gt; newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY &gt; 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				that.size.height = gridY;
				that.position.top = op.top + os.height - gridY;
			}
			if ( newWidth - gridX &gt; 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				that.size.width = gridX;
				that.position.left = op.left + os.width - gridX;
			}
		}
	}

});

})(jQuery);
(function( $, undefined ) {

var lastActive,
	baseClasses = &quot;ui-button ui-widget ui-state-default ui-corner-all&quot;,
	typeClasses = &quot;ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only&quot;,
	formResetHandler = function() {
		var form = $( this );
		setTimeout(function() {
			form.find( &quot;:ui-button&quot; ).button( &quot;refresh&quot; );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /&#x27;/g, &quot;\\&#x27;&quot; );
			if ( form ) {
				radios = $( form ).find( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot; );
			} else {
				radios = $( &quot;[name=&#x27;&quot; + name + &quot;&#x27;]&quot;, radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( &quot;ui.button&quot;, {
	version: &quot;1.10.4&quot;,
	defaultElement: &quot;&lt;button&gt;&quot;,
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( &quot;form&quot; )
			.unbind( &quot;reset&quot; + this.eventNamespace )
			.bind( &quot;reset&quot; + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== &quot;boolean&quot; ) {
			this.options.disabled = !!this.element.prop( &quot;disabled&quot; );
		} else {
			this.element.prop( &quot;disabled&quot;, this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( &quot;title&quot; );

		var that = this,
			options = this.options,
			toggleButton = this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot;,
			activeClass = !toggleButton ? &quot;ui-state-active&quot; : &quot;&quot;;

		if ( options.label === null ) {
			options.label = (this.type === &quot;input&quot; ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( &quot;role&quot;, &quot;button&quot; )
			.bind( &quot;mouseenter&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( &quot;ui-state-active&quot; );
				}
			})
			.bind( &quot;mouseleave&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( &quot;click&quot; + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		// Can&#x27;t use _focusable() because the element that receives focus
		// and the element that gets the ui-state-focus class are different
		this._on({
			focus: function() {
				this.buttonElement.addClass( &quot;ui-state-focus&quot; );
			},
			blur: function() {
				this.buttonElement.removeClass( &quot;ui-state-focus&quot; );
			}
		});

		if ( toggleButton ) {
			this.element.bind( &quot;change&quot; + this.eventNamespace, function() {
				that.refresh();
			});
		}

		if ( this.type === &quot;checkbox&quot; ) {
			this.buttonElement.bind( &quot;click&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
			});
		} else if ( this.type === &quot;radio&quot; ) {
			this.buttonElement.bind( &quot;click&quot; + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).addClass( &quot;ui-state-active&quot; );
				that.buttonElement.attr( &quot;aria-pressed&quot;, &quot;true&quot; );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( &quot;widget&quot; )[ 0 ];
					})
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			});
		} else {
			this.buttonElement
				.bind( &quot;mousedown&quot; + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( &quot;ui-state-active&quot; );
					lastActive = this;
					that.document.one( &quot;mouseup&quot;, function() {
						lastActive = null;
					});
				})
				.bind( &quot;mouseup&quot; + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( &quot;ui-state-active&quot; );
				})
				.bind( &quot;keydown&quot; + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( &quot;ui-state-active&quot; );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an &quot;active&quot; state
				.bind( &quot;keyup&quot; + this.eventNamespace + &quot; blur&quot; + this.eventNamespace, function() {
					$( this ).removeClass( &quot;ui-state-active&quot; );
				});

			if ( this.buttonElement.is(&quot;a&quot;) ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn&#x27;t work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget&#x27;s handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it&#x27;s easy to proxy and can
		// be overridden by individual plugins
		this._setOption( &quot;disabled&quot;, options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is(&quot;[type=checkbox]&quot;) ) {
			this.type = &quot;checkbox&quot;;
		} else if ( this.element.is(&quot;[type=radio]&quot;) ) {
			this.type = &quot;radio&quot;;
		} else if ( this.element.is(&quot;input&quot;) ) {
			this.type = &quot;input&quot;;
		} else {
			this.type = &quot;button&quot;;
		}

		if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
			// we don&#x27;t search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = &quot;label[for=&#x27;&quot; + this.element.attr(&quot;id&quot;) + &quot;&#x27;]&quot;;
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( &quot;ui-helper-hidden-accessible&quot; );

			checked = this.element.is( &quot;:checked&quot; );
			if ( checked ) {
				this.buttonElement.addClass( &quot;ui-state-active&quot; );
			}
			this.buttonElement.prop( &quot;aria-pressed&quot;, checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( &quot;ui-helper-hidden-accessible&quot; );
		this.buttonElement
			.removeClass( baseClasses + &quot; ui-state-active &quot; + typeClasses )
			.removeAttr( &quot;role&quot; )
			.removeAttr( &quot;aria-pressed&quot; )
			.html( this.buttonElement.find(&quot;.ui-button-text&quot;).html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( &quot;title&quot; );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === &quot;disabled&quot; ) {
			this.element.prop( &quot;disabled&quot;, !!value );
			if ( value ) {
				this.buttonElement.removeClass( &quot;ui-state-focus&quot; );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 &amp; #8828
		var isDisabled = this.element.is( &quot;input, button&quot; ) ? this.element.is( &quot;:disabled&quot; ) : this.element.hasClass( &quot;ui-button-disabled&quot; );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( &quot;disabled&quot;, isDisabled );
		}
		if ( this.type === &quot;radio&quot; ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( &quot;:checked&quot; ) ) {
					$( this ).button( &quot;widget&quot; )
						.addClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
				} else {
					$( this ).button( &quot;widget&quot; )
						.removeClass( &quot;ui-state-active&quot; )
						.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
				}
			});
		} else if ( this.type === &quot;checkbox&quot; ) {
			if ( this.element.is( &quot;:checked&quot; ) ) {
				this.buttonElement
					.addClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;true&quot; );
			} else {
				this.buttonElement
					.removeClass( &quot;ui-state-active&quot; )
					.attr( &quot;aria-pressed&quot;, &quot;false&quot; );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === &quot;input&quot; ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( &quot;&lt;span&gt;&lt;/span&gt;&quot;, this.document[0] )
				.addClass( &quot;ui-button-text&quot; )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary &amp;&amp; icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( &quot;ui-button-text-icon&quot; + ( multipleIcons ? &quot;s&quot; : ( icons.primary ? &quot;-primary&quot; : &quot;-secondary&quot; ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( &quot;&lt;span class=&#x27;ui-button-icon-primary ui-icon &quot; + icons.primary + &quot;&#x27;&gt;&lt;/span&gt;&quot; );
			}

			if ( icons.secondary ) {
				buttonElement.append( &quot;&lt;span class=&#x27;ui-button-icon-secondary ui-icon &quot; + icons.secondary + &quot;&#x27;&gt;&lt;/span&gt;&quot; );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? &quot;ui-button-icons-only&quot; : &quot;ui-button-icon-only&quot; );

				if ( !this.hasTitle ) {
					buttonElement.attr( &quot;title&quot;, $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( &quot;ui-button-text-only&quot; );
		}
		buttonElement.addClass( buttonClasses.join( &quot; &quot; ) );
	}
});

$.widget( &quot;ui.buttonset&quot;, {
	version: &quot;1.10.4&quot;,
	options: {
		items: &quot;button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)&quot;
	},

	_create: function() {
		this.element.addClass( &quot;ui-buttonset&quot; );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === &quot;disabled&quot; ) {
			this.buttons.button( &quot;option&quot;, key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( &quot;direction&quot; ) === &quot;rtl&quot;;

		this.buttons = this.element.find( this.options.items )
			.filter( &quot;:ui-button&quot; )
				.button( &quot;refresh&quot; )
			.end()
			.not( &quot;:ui-button&quot; )
				.button()
			.end()
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-all ui-corner-left ui-corner-right&quot; )
				.filter( &quot;:first&quot; )
					.addClass( rtl ? &quot;ui-corner-right&quot; : &quot;ui-corner-left&quot; )
				.end()
				.filter( &quot;:last&quot; )
					.addClass( rtl ? &quot;ui-corner-left&quot; : &quot;ui-corner-right&quot; )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( &quot;ui-buttonset&quot; );
		this.buttons
			.map(function() {
				return $( this ).button( &quot;widget&quot; )[ 0 ];
			})
				.removeClass( &quot;ui-corner-left ui-corner-right&quot; )
			.end()
			.button( &quot;destroy&quot; );
	}
});

}( jQuery ) );
(function( $, undefined ) {

var sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget( &quot;ui.dialog&quot;, {
	version: &quot;1.10.4&quot;,
	options: {
		appendTo: &quot;body&quot;,
		autoOpen: true,
		buttons: [],
		closeOnEscape: true,
		closeText: &quot;close&quot;,
		dialogClass: &quot;&quot;,
		draggable: true,
		hide: null,
		height: &quot;auto&quot;,
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: &quot;center&quot;,
			at: &quot;center&quot;,
			of: window,
			collision: &quot;fit&quot;,
			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset &lt; 0 ) {
					$( this ).css( &quot;top&quot;, pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	_create: function() {
		this.originalCss = {
			display: this.element[0].style.display,
			width: this.element[0].style.width,
			minHeight: this.element[0].style.minHeight,
			maxHeight: this.element[0].style.maxHeight,
			height: this.element[0].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr(&quot;title&quot;);
		this.options.title = this.options.title || this.originalTitle;

		this._createWrapper();

		this.element
			.show()
			.removeAttr(&quot;title&quot;)
			.addClass(&quot;ui-dialog-content ui-widget-content&quot;)
			.appendTo( this.uiDialog );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable &amp;&amp; $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable &amp;&amp; $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element &amp;&amp; (element.jquery || element.nodeType) ) {
			return $( element );
		}
		return this.document.find( element || &quot;body&quot; ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.removeClass(&quot;ui-dialog-content ui-widget-content&quot;)
			.css( this.originalCss )
			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.stop( true, true ).remove();

		if ( this.originalTitle ) {
			this.element.attr( &quot;title&quot;, this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );
		// Don&#x27;t try to place the dialog next to itself (#8613)
		if ( next.length &amp;&amp; next[0] !== this.element[0] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var activeElement,
			that = this;

		if ( !this._isOpen || this._trigger( &quot;beforeClose&quot;, event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._destroyOverlay();

		if ( !this.opener.filter(&quot;:focusable&quot;).focus().length ) {

			// support: IE9
			// IE9 throws an &quot;Unspecified error&quot; accessing document.activeElement from an &lt;iframe&gt;
			try {
				activeElement = this.document[ 0 ].activeElement;

				// Support: IE9, IE10
				// If the &lt;body&gt; is blurred, IE will switch windows, see #4520
				if ( activeElement &amp;&amp; activeElement.nodeName.toLowerCase() !== &quot;body&quot; ) {

					// Hiding a focused element doesn&#x27;t trigger blur in WebKit
					// so in case we have nothing to focus on, explicitly blur the active element
					// https://bugs.webkit.org/show_bug.cgi?id=47182
					$( activeElement ).blur();
				}
			} catch ( error ) {}
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( &quot;close&quot;, event );
		});
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = !!this.uiDialog.nextAll(&quot;:visible&quot;).insertBefore( this.uiDialog ).length;
		if ( moved &amp;&amp; !silent ) {
			this._trigger( &quot;focus&quot;, event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( this.document[0].activeElement );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );
		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger(&quot;focus&quot;);
		});

		this._trigger(&quot;open&quot;);
	},

	_focusTabbable: function() {
		// Set focus to the first match:
		// 1. First element inside the dialog matching [autofocus]
		// 2. Tabbable element inside the content element
		// 3. Tabbable element inside the buttonpane
		// 4. The close button
		// 5. The dialog itself
		var hasFocus = this.element.find(&quot;[autofocus]&quot;);
		if ( !hasFocus.length ) {
			hasFocus = this.element.find(&quot;:tabbable&quot;);
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find(&quot;:tabbable&quot;);
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter(&quot;:tabbable&quot;);
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = this.document[0].activeElement,
				isActive = this.uiDialog[0] === activeElement ||
					$.contains( this.uiDialog[0], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );
		// support: IE
		// IE &lt;= 8 doesn&#x27;t prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $(&quot;&lt;div&gt;&quot;)
			.addClass( &quot;ui-dialog ui-widget ui-widget-content ui-corner-all ui-front &quot; +
				this.options.dialogClass )
			.hide()
			.attr({
				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: &quot;dialog&quot;
			})
			.appendTo( this._appendTo() );

		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape &amp;&amp; !event.isDefaultPrevented() &amp;&amp; event.keyCode &amp;&amp;
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB ) {
					return;
				}
				var tabbables = this.uiDialog.find(&quot;:tabbable&quot;),
					first = tabbables.filter(&quot;:first&quot;),
					last  = tabbables.filter(&quot;:last&quot;);

				if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) &amp;&amp; !event.shiftKey ) {
					first.focus( 1 );
					event.preventDefault();
				} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) &amp;&amp; event.shiftKey ) {
					last.focus( 1 );
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		});

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find(&quot;[aria-describedby]&quot;).length ) {
			this.uiDialog.attr({
				&quot;aria-describedby&quot;: this.element.uniqueId().attr(&quot;id&quot;)
			});
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $(&quot;&lt;div&gt;&quot;)
			.addClass(&quot;ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix&quot;)
			.prependTo( this.uiDialog );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {
				// Don&#x27;t prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest(&quot;.ui-dialog-titlebar-close&quot;) ) {
					// Dialog isn&#x27;t getting focus when dragging (#8063)
					this.uiDialog.focus();
				}
			}
		});

		// support: IE
		// Use type=&quot;button&quot; to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( &quot;&lt;button type=&#x27;button&#x27;&gt;&lt;/button&gt;&quot; )
			.button({
				label: this.options.closeText,
				icons: {
					primary: &quot;ui-icon-closethick&quot;
				},
				text: false
			})
			.addClass(&quot;ui-dialog-titlebar-close&quot;)
			.appendTo( this.uiDialogTitlebar );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		});

		uiDialogTitle = $(&quot;&lt;span&gt;&quot;)
			.uniqueId()
			.addClass(&quot;ui-dialog-title&quot;)
			.prependTo( this.uiDialogTitlebar );
		this._title( uiDialogTitle );

		this.uiDialog.attr({
			&quot;aria-labelledby&quot;: uiDialogTitle.attr(&quot;id&quot;)
		});
	},

	_title: function( title ) {
		if ( !this.options.title ) {
			title.html(&quot;&amp;#160;&quot;);
		}
		title.text( this.options.title );
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $(&quot;&lt;div&gt;&quot;)
			.addClass(&quot;ui-dialog-buttonpane ui-widget-content ui-helper-clearfix&quot;);

		this.uiButtonSet = $(&quot;&lt;div&gt;&quot;)
			.addClass(&quot;ui-dialog-buttonset&quot;)
			.appendTo( this.uiDialogButtonPane );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) &amp;&amp; !buttons.length) ) {
			this.uiDialog.removeClass(&quot;ui-dialog-buttons&quot;);
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;
			// Default to a non-submitting button
			props = $.extend( { type: &quot;button&quot; }, props );
			// Change the context for the click callback to be the main element
			click = props.click;
			props.click = function() {
				click.apply( that.element[0], arguments );
			};
			buttonOptions = {
				icons: props.icons,
				text: props.showText
			};
			delete props.icons;
			delete props.showText;
			$( &quot;&lt;button&gt;&lt;/button&gt;&quot;, props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet );
		});
		this.uiDialog.addClass(&quot;ui-dialog-buttons&quot;);
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: &quot;.ui-dialog-content, .ui-dialog-titlebar-close&quot;,
			handle: &quot;.ui-dialog-titlebar&quot;,
			containment: &quot;document&quot;,
			start: function( event, ui ) {
				$( this ).addClass(&quot;ui-dialog-dragging&quot;);
				that._blockFrames();
				that._trigger( &quot;dragStart&quot;, event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( &quot;drag&quot;, event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this ).removeClass(&quot;ui-dialog-dragging&quot;);
				that._unblockFrames();
				that._trigger( &quot;dragStop&quot;, event, filteredUi( ui ) );
			}
		});
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css(&quot;position&quot;),
			resizeHandles = typeof handles === &quot;string&quot; ?
				handles	:
				&quot;n,e,s,w,se,sw,ne,nw&quot;;

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: &quot;.ui-dialog-content&quot;,
			containment: &quot;document&quot;,
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass(&quot;ui-dialog-resizing&quot;);
				that._blockFrames();
				that._trigger( &quot;resizeStart&quot;, event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( &quot;resize&quot;, event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.height = $( this ).height();
				options.width = $( this ).width();
				$( this ).removeClass(&quot;ui-dialog-resizing&quot;);
				that._unblockFrames();
				that._trigger( &quot;resizeStop&quot;, event, filteredUi( ui ) );
			}
		})
		.css( &quot;position&quot;, position );
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === &quot;auto&quot; ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {
		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is(&quot;:visible&quot;);
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is(&quot;:data(ui-resizable)&quot;) ) {
			this.uiDialog.resizable( &quot;option&quot;, resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === &quot;dialogClass&quot; ) {
			uiDialog
				.removeClass( this.options.dialogClass )
				.addClass( value );
		}

		if ( key === &quot;disabled&quot; ) {
			return;
		}

		this._super( key, value );

		if ( key === &quot;appendTo&quot; ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === &quot;buttons&quot; ) {
			this._createButtons();
		}

		if ( key === &quot;closeText&quot; ) {
			this.uiDialogTitlebarClose.button({
				// Ensure that we always pass a string
				label: &quot;&quot; + value
			});
		}

		if ( key === &quot;draggable&quot; ) {
			isDraggable = uiDialog.is(&quot;:data(ui-draggable)&quot;);
			if ( isDraggable &amp;&amp; !value ) {
				uiDialog.draggable(&quot;destroy&quot;);
			}

			if ( !isDraggable &amp;&amp; value ) {
				this._makeDraggable();
			}
		}

		if ( key === &quot;position&quot; ) {
			this._position();
		}

		if ( key === &quot;resizable&quot; ) {
			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is(&quot;:data(ui-resizable)&quot;);
			if ( isResizable &amp;&amp; !value ) {
				uiDialog.resizable(&quot;destroy&quot;);
			}

			// currently resizable, changing handles
			if ( isResizable &amp;&amp; typeof value === &quot;string&quot; ) {
				uiDialog.resizable( &quot;option&quot;, &quot;handles&quot;, value );
			}

			// currently non-resizable, becoming resizable
			if ( !isResizable &amp;&amp; value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === &quot;title&quot; ) {
			this._title( this.uiDialogTitlebar.find(&quot;.ui-dialog-title&quot;) );
		}
	},

	_size: function() {
		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css({
			width: &quot;auto&quot;,
			minHeight: 0,
			maxHeight: &quot;none&quot;,
			height: 0
		});

		if ( options.minWidth &gt; options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: &quot;auto&quot;,
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === &quot;number&quot; ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			&quot;none&quot;;

		if ( options.height === &quot;auto&quot; ) {
			this.element.css({
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: &quot;auto&quot;
			});
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if (this.uiDialog.is(&quot;:data(ui-resizable)&quot;) ) {
			this.uiDialog.resizable( &quot;option&quot;, &quot;minHeight&quot;, this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( &quot;iframe&quot; ).map(function() {
			var iframe = $( this );

			return $( &quot;&lt;div&gt;&quot; )
				.css({
					position: &quot;absolute&quot;,
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				})
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[0];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest(&quot;.ui-dialog&quot;).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest(&quot;.ui-datepicker&quot;).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		var that = this,
			widgetFullName = this.widgetFullName;
		if ( !$.ui.dialog.overlayInstances ) {
			// Prevent use of anchors and inputs.
			// We use a delay in case the overlay is created from an
			// event that we&#x27;re going to be cancelling. (#2804)
			this._delay(function() {
				// Handle .dialog().dialog(&quot;close&quot;) (#4065)
				if ( $.ui.dialog.overlayInstances ) {
					this.document.bind( &quot;focusin.dialog&quot;, function( event ) {
						if ( !that._allowInteraction( event ) ) {
							event.preventDefault();
							$(&quot;.ui-dialog:visible:last .ui-dialog-content&quot;)
								.data( widgetFullName )._focusTabbable();
						}
					});
				}
			});
		}

		this.overlay = $(&quot;&lt;div&gt;&quot;)
			.addClass(&quot;ui-widget-overlay ui-front&quot;)
			.appendTo( this._appendTo() );
		this._on( this.overlay, {
			mousedown: &quot;_keepFocus&quot;
		});
		$.ui.dialog.overlayInstances++;
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			$.ui.dialog.overlayInstances--;

			if ( !$.ui.dialog.overlayInstances ) {
				this.document.unbind( &quot;focusin.dialog&quot; );
			}
			this.overlay.remove();
			this.overlay = null;
		}
	}
});

$.ui.dialog.overlayInstances = 0;

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// position option with array notation
	// just override with old implementation
	$.widget( &quot;ui.dialog&quot;, $.ui.dialog, {
		_position: function() {
			var position = this.options.position,
				myAt = [],
				offset = [ 0, 0 ],
				isVisible;

			if ( position ) {
				if ( typeof position === &quot;string&quot; || (typeof position === &quot;object&quot; &amp;&amp; &quot;0&quot; in position ) ) {
					myAt = position.split ? position.split(&quot; &quot;) : [ position[0], position[1] ];
					if ( myAt.length === 1 ) {
						myAt[1] = myAt[0];
					}

					$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, offsetPosition ) {
						if ( +myAt[ i ] === myAt[ i ] ) {
							offset[ i ] = myAt[ i ];
							myAt[ i ] = offsetPosition;
						}
					});

					position = {
						my: myAt[0] + (offset[0] &lt; 0 ? offset[0] : &quot;+&quot; + offset[0]) + &quot; &quot; +
							myAt[1] + (offset[1] &lt; 0 ? offset[1] : &quot;+&quot; + offset[1]),
						at: myAt.join(&quot; &quot;)
					};
				}

				position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
			} else {
				position = $.ui.dialog.prototype.options.position;
			}

			// need to show the dialog to get the actual offset in the position plugin
			isVisible = this.uiDialog.is(&quot;:visible&quot;);
			if ( !isVisible ) {
				this.uiDialog.show();
			}
			this.uiDialog.position( position );
			if ( !isVisible ) {
				this.uiDialog.hide();
			}
		}
	});
}

}( jQuery ) );
(function($, undefined) {

var dataSpace = &quot;ui-effects-&quot;;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = &quot;backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor&quot;,

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE&#x27;s that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: &quot;hsla&quot;,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: &quot;byte&quot;
				},
				green: {
					idx: 1,
					type: &quot;byte&quot;
				},
				blue: {
					idx: 2,
					type: &quot;byte&quot;
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: &quot;degrees&quot;
				},
				saturation: {
					idx: 1,
					type: &quot;percent&quot;
				},
				lightness: {
					idx: 2,
					type: &quot;percent&quot;
				}
			}
		}
	},
	propTypes = {
		&quot;byte&quot;: {
			floor: true,
			max: 255
		},
		&quot;percent&quot;: {
			max: 1
		},
		&quot;degrees&quot;: {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( &quot;&lt;p&gt;&quot; )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = &quot;background-color:rgba(1,1,1,.5)&quot;;
support.rgba = supportElem.style.backgroundColor.indexOf( &quot;rgba&quot; ) &gt; -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = &quot;_&quot; + spaceName;
	space.props.alpha = {
		idx: 3,
		type: &quot;percent&quot;,
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -&gt; 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 &gt; value ? 0 : type.max &lt; value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match &amp;&amp; parser.parse( match ),
			spaceName = parser.space || &quot;rgba&quot;;

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force &quot;transparent&quot; when alpha is 0
		// chrome, (and maybe others) return &quot;transparent&quot; as rgba(0,0,0,0)
		if ( rgba.join() === &quot;0,0,0,0&quot; ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = &quot;array&quot;;
		}

		if ( type === &quot;string&quot; ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === &quot;array&quot; ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === &quot;object&quot; ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn&#x27;t exist, and we know how to convert
						if ( !inst[ cache ] &amp;&amp; space.to ) {

							// if the value was null, we don&#x27;t need to copy it
							// if the key was alpha, we don&#x27;t need to copy it either
							if ( key === &quot;alpha&quot; || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] &amp;&amp; jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) &lt; 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to &amp;&amp; space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( &quot;transparent&quot; ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don&#x27;t override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue &gt; type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue &gt; type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = &quot;rgba(&quot;,
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i &gt; 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = &quot;rgb(&quot;;
		}

		return prefix + rgba.join() + &quot;)&quot;;
	},
	toHslaString: function() {
		var prefix = &quot;hsla(&quot;,
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i &gt; 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i &amp;&amp; i &lt; 3 ) {
					v = Math.round( v * 100 ) + &quot;%&quot;;
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = &quot;hsl(&quot;;
		}
		return prefix + hsla.join() + &quot;)&quot;;
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return &quot;#&quot; + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? &quot;0&quot; + v : v;
		}).join(&quot;&quot;);
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? &quot;transparent&quot; : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 &lt; 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 &lt; 1) {
		return q;
	}
	if ( h * 3 &lt; 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l &lt;= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l &lt;= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn&#x27;t exist
		if ( to &amp;&amp; !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === &quot;array&quot; || type === &quot;object&quot; ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === &quot;object&quot; ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === &quot;alpha&quot; ? ( this._hsla ? &quot;hsla&quot; : &quot;rgba&quot; ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === &quot;undefined&quot; ) {
				return cur;
			}

			if ( vtype === &quot;function&quot; ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null &amp;&amp; prop.empty ) {
				return this;
			}
			if ( vtype === &quot;string&quot; ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === &quot;+&quot; ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( &quot; &quot; );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = &quot;&quot;;

				if ( value !== &quot;transparent&quot; &amp;&amp; ( jQuery.type( value ) !== &quot;string&quot; || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba &amp;&amp; value._rgba[ 3 ] !== 1 ) {
						curElem = hook === &quot;backgroundColor&quot; ? elem.parentNode : elem;
						while (
							(backgroundColor === &quot;&quot; || backgroundColor === &quot;transparent&quot;) &amp;&amp;
							curElem &amp;&amp; curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, &quot;backgroundColor&quot; );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor &amp;&amp; backgroundColor !== &quot;transparent&quot; ?
							backgroundColor :
							&quot;_default&quot; );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on &quot;invalid&quot; values like &#x27;auto&#x27; or &#x27;inherit&#x27;
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ], function( i, part ) {
			expanded[ &quot;border&quot; + part + &quot;Color&quot; ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: &quot;#00ffff&quot;,
	black: &quot;#000000&quot;,
	blue: &quot;#0000ff&quot;,
	fuchsia: &quot;#ff00ff&quot;,
	gray: &quot;#808080&quot;,
	green: &quot;#008000&quot;,
	lime: &quot;#00ff00&quot;,
	maroon: &quot;#800000&quot;,
	navy: &quot;#000080&quot;,
	olive: &quot;#808000&quot;,
	purple: &quot;#800080&quot;,
	red: &quot;#ff0000&quot;,
	silver: &quot;#c0c0c0&quot;,
	teal: &quot;#008080&quot;,
	white: &quot;#ffffff&quot;,
	yellow: &quot;#ffff00&quot;,

	// 4.2.3. &quot;transparent&quot; color keyword
	transparent: [ null, null, null, 0 ],

	_default: &quot;#ffffff&quot;
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ &quot;add&quot;, &quot;remove&quot;, &quot;toggle&quot; ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ &quot;borderLeftStyle&quot;, &quot;borderRightStyle&quot;, &quot;borderBottomStyle&quot;, &quot;borderTopStyle&quot; ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== &quot;none&quot; &amp;&amp; !fx.setAttr || fx.pos === 1 &amp;&amp; !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style &amp;&amp; style.length &amp;&amp; style[ 0 ] &amp;&amp; style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === &quot;string&quot; ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE &lt;9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === &quot;string&quot; ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery &lt;1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( &quot;class&quot; ) || &quot;&quot;,
			applyClassChange,
			allAnimations = o.children ? animated.find( &quot;*&quot; ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + &quot;Class&quot; ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( &quot;class&quot;, baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, &quot;&quot; );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length &gt; 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === &quot;boolean&quot; || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: &quot;1.10.4&quot;,

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can&#x27;t differentiate between &quot;&quot; and 0 here, so we just assume
				// empty string since it&#x27;s likely to be a more common value...
				if ( val === undefined ) {
					val = &quot;&quot;;
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === &quot;toggle&quot;) {
			mode = el.is( &quot;:hidden&quot; ) ? &quot;show&quot; : &quot;hide&quot;;
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string &amp; hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case &quot;top&quot;: y = 0; break;
			case &quot;middle&quot;: y = 0.5; break;
			case &quot;bottom&quot;: y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case &quot;left&quot;: x = 0; break;
			case &quot;center&quot;: x = 0.5; break;
			case &quot;right&quot;: x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				&quot;float&quot;: element.css( &quot;float&quot; )
			},
			wrapper = $( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
				.addClass( &quot;ui-effects-wrapper&quot; )
				.css({
					fontSize: &quot;100%&quot;,
					background: &quot;transparent&quot;,
					border: &quot;none&quot;,
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( &quot;position&quot; ) === &quot;static&quot; ) {
			wrapper.css({ position: &quot;relative&quot; });
			element.css({ position: &quot;relative&quot; });
		} else {
			$.extend( props, {
				position: element.css( &quot;position&quot; ),
				zIndex: element.css( &quot;z-index&quot; )
			});
			$.each([ &quot;top&quot;, &quot;left&quot;, &quot;bottom&quot;, &quot;right&quot; ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = &quot;auto&quot;;
				}
			});
			element.css({
				position: &quot;relative&quot;,
				top: 0,
				left: 0,
				right: &quot;auto&quot;,
				bottom: &quot;auto&quot;
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] &gt; 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === &quot;number&quot; || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === &quot;number&quot; ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === &quot;number&quot; || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as &quot;normal&quot; speed
	if ( typeof option === &quot;string&quot; &amp;&amp; !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === &quot;object&quot; &amp;&amp; !option.effect ) {
		return true;
	}

	// Didn&#x27;t match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of &quot;olddisplay&quot; works.
			if ( elem.is( &quot;:hidden&quot; ) ? mode === &quot;hide&quot; : mode === &quot;show&quot; ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || &quot;fx&quot;, run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = &quot;show&quot;;
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = &quot;hide&quot;;
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === &quot;boolean&quot; ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = &quot;toggle&quot;;
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ &quot;em&quot;, &quot;px&quot;, &quot;%&quot;, &quot;pt&quot; ], function( i, unit ) {
			if ( style.indexOf( unit ) &gt; 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ &quot;Quad&quot;, &quot;Cubic&quot;, &quot;Quart&quot;, &quot;Quint&quot;, &quot;Expo&quot; ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p &lt; ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ &quot;easeIn&quot; + name ] = easeIn;
	$.easing[ &quot;easeOut&quot; + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ &quot;easeInOut&quot; + name ] = function( p ) {
		return p &lt; 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery);
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || &quot;toggle&quot; );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, &quot;height&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;show&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;left&quot;,
		ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,
		positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot; ]( true );

	$.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? &quot;-&quot; + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? &quot;+=&quot; : &quot;-=&quot;) :
		( positiveMotion ? &quot;-=&quot; : &quot;+=&quot;)) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
