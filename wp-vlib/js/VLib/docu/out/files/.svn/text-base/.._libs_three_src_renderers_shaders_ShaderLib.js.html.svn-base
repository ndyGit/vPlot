<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../libs/three/src/renderers/shaders/ShaderLib.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AbstractPlugin.html">AbstractPlugin</a></li>
            
                <li><a href="../classes/Config.html">Config</a></li>
            
                <li><a href="../classes/Controls.html">Controls</a></li>
            
                <li><a href="../classes/Plot.html">Plot</a></li>
            
                <li><a href="../classes/Plugin 3D.html">Plugin 3D</a></li>
            
                <li><a href="../classes/Plugin Axes.html">Plugin Axes</a></li>
            
                <li><a href="../classes/Plugin BasicMaterial.html">Plugin BasicMaterial</a></li>
            
                <li><a href="../classes/Plugin CameraControl.html">Plugin CameraControl</a></li>
            
                <li><a href="../classes/Plugin Color.html">Plugin Color</a></li>
            
                <li><a href="../classes/Plugin Dataset.html">Plugin Dataset</a></li>
            
                <li><a href="../classes/Plugin File.html">Plugin File</a></li>
            
                <li><a href="../classes/Plugin Function.html">Plugin Function</a></li>
            
                <li><a href="../classes/Plugin Heatmap.html">Plugin Heatmap</a></li>
            
                <li><a href="../classes/Plugin Light.html">Plugin Light</a></li>
            
                <li><a href="../classes/Plugin LinePlot.html">Plugin LinePlot</a></li>
            
                <li><a href="../classes/Plugin Plane.html">Plugin Plane</a></li>
            
                <li><a href="../classes/Plugin ScatterPlot.html">Plugin ScatterPlot</a></li>
            
                <li><a href="../classes/Plugin SurfacePlot.html">Plugin SurfacePlot</a></li>
            
                <li><a href="../classes/Plugin WireframeMaterial.html">Plugin WireframeMaterial</a></li>
            
                <li><a href="../classes/SceneGraph.html">SceneGraph</a></li>
            
                <li><a href="../classes/Templates.html">Templates</a></li>
            
                <li><a href="../classes/Toolbox.html">Toolbox</a></li>
            
                <li><a href="../classes/UTILS.html">UTILS</a></li>
            
                <li><a href="../classes/VLib.html">VLib</a></li>
            
                <li><a href="../classes/VMediator.html">VMediator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Controls.html">Controls</a></li>
            
                <li><a href="../modules/main.html">main</a></li>
            
                <li><a href="../modules/Plot.html">Plot</a></li>
            
                <li><a href="../modules/SceneGraph.html">SceneGraph</a></li>
            
                <li><a href="../modules/Templates.html">Templates</a></li>
            
                <li><a href="../modules/Toolbox.html">Toolbox</a></li>
            
                <li><a href="../modules/VLib.html">VLib</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../libs/three/src/renderers/shaders/ShaderLib.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	&#x27;basic&#x27;: {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;common&quot; ],
			THREE.UniformsLib[ &quot;fog&quot; ],
			THREE.UniformsLib[ &quot;shadowmap&quot; ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ &quot;map_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;color_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;morphtarget_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;skinning_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;map_vertex&quot; ],
				THREE.ShaderChunk[ &quot;lightmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;color_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinbase_vertex&quot; ],

				&quot;#ifdef USE_ENVMAP&quot;,

				THREE.ShaderChunk[ &quot;morphnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;defaultnormal_vertex&quot; ],

				&quot;#endif&quot;,

				THREE.ShaderChunk[ &quot;morphtarget_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinning_vertex&quot; ],
				THREE.ShaderChunk[ &quot;default_vertex&quot; ],

				THREE.ShaderChunk[ &quot;worldpos_vertex&quot; ],
				THREE.ShaderChunk[ &quot;envmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform vec3 diffuse;&quot;,
			&quot;uniform float opacity;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;map_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;specularmap_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( diffuse, opacity );&quot;,

				THREE.ShaderChunk[ &quot;map_fragment&quot; ],
				THREE.ShaderChunk[ &quot;alphatest_fragment&quot; ],
				THREE.ShaderChunk[ &quot;specularmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;lightmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;color_fragment&quot; ],
				THREE.ShaderChunk[ &quot;envmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_fragment&quot; ],

				THREE.ShaderChunk[ &quot;linear_to_gamma_fragment&quot; ],

				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;lambert&#x27;: {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;common&quot; ],
			THREE.UniformsLib[ &quot;fog&quot; ],
			THREE.UniformsLib[ &quot;lights&quot; ],
			THREE.UniformsLib[ &quot;shadowmap&quot; ],

			{
				&quot;ambient&quot;  : { type: &quot;c&quot;, value: new THREE.Color( 0xffffff ) },
				&quot;emissive&quot; : { type: &quot;c&quot;, value: new THREE.Color( 0x000000 ) },
				&quot;wrapRGB&quot;  : { type: &quot;v3&quot;, value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			&quot;#define LAMBERT&quot;,

			&quot;varying vec3 vLightFront;&quot;,

			&quot;#ifdef DOUBLE_SIDED&quot;,

				&quot;varying vec3 vLightBack;&quot;,

			&quot;#endif&quot;,

			THREE.ShaderChunk[ &quot;map_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;lights_lambert_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;color_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;morphtarget_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;skinning_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;map_vertex&quot; ],
				THREE.ShaderChunk[ &quot;lightmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;color_vertex&quot; ],

				THREE.ShaderChunk[ &quot;morphnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinbase_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;defaultnormal_vertex&quot; ],

				THREE.ShaderChunk[ &quot;morphtarget_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinning_vertex&quot; ],
				THREE.ShaderChunk[ &quot;default_vertex&quot; ],

				THREE.ShaderChunk[ &quot;worldpos_vertex&quot; ],
				THREE.ShaderChunk[ &quot;envmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;lights_lambert_vertex&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform float opacity;&quot;,

			&quot;varying vec3 vLightFront;&quot;,

			&quot;#ifdef DOUBLE_SIDED&quot;,

				&quot;varying vec3 vLightBack;&quot;,

			&quot;#endif&quot;,

			THREE.ShaderChunk[ &quot;color_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;map_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;specularmap_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( vec3 ( 1.0 ), opacity );&quot;,

				THREE.ShaderChunk[ &quot;map_fragment&quot; ],
				THREE.ShaderChunk[ &quot;alphatest_fragment&quot; ],
				THREE.ShaderChunk[ &quot;specularmap_fragment&quot; ],

				&quot;#ifdef DOUBLE_SIDED&quot;,

					//&quot;float isFront = float( gl_FrontFacing );&quot;,
					//&quot;gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;&quot;,

					&quot;if ( gl_FrontFacing )&quot;,
						&quot;gl_FragColor.xyz *= vLightFront;&quot;,
					&quot;else&quot;,
						&quot;gl_FragColor.xyz *= vLightBack;&quot;,

				&quot;#else&quot;,

					&quot;gl_FragColor.xyz *= vLightFront;&quot;,

				&quot;#endif&quot;,

				THREE.ShaderChunk[ &quot;lightmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;color_fragment&quot; ],
				THREE.ShaderChunk[ &quot;envmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_fragment&quot; ],

				THREE.ShaderChunk[ &quot;linear_to_gamma_fragment&quot; ],

				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;phong&#x27;: {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;common&quot; ],
			THREE.UniformsLib[ &quot;bump&quot; ],
			THREE.UniformsLib[ &quot;normalmap&quot; ],
			THREE.UniformsLib[ &quot;fog&quot; ],
			THREE.UniformsLib[ &quot;lights&quot; ],
			THREE.UniformsLib[ &quot;shadowmap&quot; ],

			{
				&quot;ambient&quot;  : { type: &quot;c&quot;, value: new THREE.Color( 0xffffff ) },
				&quot;emissive&quot; : { type: &quot;c&quot;, value: new THREE.Color( 0x000000 ) },
				&quot;specular&quot; : { type: &quot;c&quot;, value: new THREE.Color( 0x111111 ) },
				&quot;shininess&quot;: { type: &quot;f&quot;, value: 30 },
				&quot;wrapRGB&quot;  : { type: &quot;v3&quot;, value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			&quot;#define PHONG&quot;,

			&quot;varying vec3 vViewPosition;&quot;,
			&quot;varying vec3 vNormal;&quot;,

			THREE.ShaderChunk[ &quot;map_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;lights_phong_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;color_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;morphtarget_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;skinning_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;map_vertex&quot; ],
				THREE.ShaderChunk[ &quot;lightmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;color_vertex&quot; ],

				THREE.ShaderChunk[ &quot;morphnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinbase_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinnormal_vertex&quot; ],
				THREE.ShaderChunk[ &quot;defaultnormal_vertex&quot; ],

				&quot;vNormal = normalize( transformedNormal );&quot;,

				THREE.ShaderChunk[ &quot;morphtarget_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinning_vertex&quot; ],
				THREE.ShaderChunk[ &quot;default_vertex&quot; ],

				&quot;vViewPosition = -mvPosition.xyz;&quot;,

				THREE.ShaderChunk[ &quot;worldpos_vertex&quot; ],
				THREE.ShaderChunk[ &quot;envmap_vertex&quot; ],
				THREE.ShaderChunk[ &quot;lights_phong_vertex&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform vec3 diffuse;&quot;,
			&quot;uniform float opacity;&quot;,

			&quot;uniform vec3 ambient;&quot;,
			&quot;uniform vec3 emissive;&quot;,
			&quot;uniform vec3 specular;&quot;,
			&quot;uniform float shininess;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;map_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;lightmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;envmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;lights_phong_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;bumpmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;normalmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;specularmap_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( vec3 ( 1.0 ), opacity );&quot;,

				THREE.ShaderChunk[ &quot;map_fragment&quot; ],
				THREE.ShaderChunk[ &quot;alphatest_fragment&quot; ],
				THREE.ShaderChunk[ &quot;specularmap_fragment&quot; ],

				THREE.ShaderChunk[ &quot;lights_phong_fragment&quot; ],

				THREE.ShaderChunk[ &quot;lightmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;color_fragment&quot; ],
				THREE.ShaderChunk[ &quot;envmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_fragment&quot; ],

				THREE.ShaderChunk[ &quot;linear_to_gamma_fragment&quot; ],

				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;particle_basic&#x27;: {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;particle&quot; ],
			THREE.UniformsLib[ &quot;shadowmap&quot; ]

		] ),

		vertexShader: [

			&quot;uniform float size;&quot;,
			&quot;uniform float scale;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;color_vertex&quot; ],

				&quot;vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );&quot;,

				&quot;#ifdef USE_SIZEATTENUATION&quot;,
					&quot;gl_PointSize = size * ( scale / length( mvPosition.xyz ) );&quot;,
				&quot;#else&quot;,
					&quot;gl_PointSize = size;&quot;,
				&quot;#endif&quot;,

				&quot;gl_Position = projectionMatrix * mvPosition;&quot;,

				THREE.ShaderChunk[ &quot;worldpos_vertex&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform vec3 psColor;&quot;,
			&quot;uniform float opacity;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;map_particle_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( psColor, opacity );&quot;,

				THREE.ShaderChunk[ &quot;map_particle_fragment&quot; ],
				THREE.ShaderChunk[ &quot;alphatest_fragment&quot; ],
				THREE.ShaderChunk[ &quot;color_fragment&quot; ],
				THREE.ShaderChunk[ &quot;shadowmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;dashed&#x27;: {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;common&quot; ],
			THREE.UniformsLib[ &quot;fog&quot; ],

			{
				&quot;scale&quot;:     { type: &quot;f&quot;, value: 1 },
				&quot;dashSize&quot;:  { type: &quot;f&quot;, value: 1 },
				&quot;totalSize&quot;: { type: &quot;f&quot;, value: 2 }
			}

		] ),

		vertexShader: [

			&quot;uniform float scale;&quot;,
			&quot;attribute float lineDistance;&quot;,

			&quot;varying float vLineDistance;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;color_vertex&quot; ],

				&quot;vLineDistance = scale * lineDistance;&quot;,

				&quot;vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );&quot;,
				&quot;gl_Position = projectionMatrix * mvPosition;&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform vec3 diffuse;&quot;,
			&quot;uniform float opacity;&quot;,

			&quot;uniform float dashSize;&quot;,
			&quot;uniform float totalSize;&quot;,

			&quot;varying float vLineDistance;&quot;,

			THREE.ShaderChunk[ &quot;color_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;if ( mod( vLineDistance, totalSize ) &gt; dashSize ) {&quot;,

					&quot;discard;&quot;,

				&quot;}&quot;,

				&quot;gl_FragColor = vec4( diffuse, opacity );&quot;,

				THREE.ShaderChunk[ &quot;color_fragment&quot; ],
				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;depth&#x27;: {

		uniforms: {

			&quot;mNear&quot;: { type: &quot;f&quot;, value: 1.0 },
			&quot;mFar&quot; : { type: &quot;f&quot;, value: 2000.0 },
			&quot;opacity&quot; : { type: &quot;f&quot;, value: 1.0 }

		},

		vertexShader: [

			&quot;void main() {&quot;,

				&quot;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform float mNear;&quot;,
			&quot;uniform float mFar;&quot;,
			&quot;uniform float opacity;&quot;,

			&quot;void main() {&quot;,

				&quot;float depth = gl_FragCoord.z / gl_FragCoord.w;&quot;,
				&quot;float color = 1.0 - smoothstep( mNear, mFar, depth );&quot;,
				&quot;gl_FragColor = vec4( vec3( color ), opacity );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	&#x27;normal&#x27;: {

		uniforms: {

			&quot;opacity&quot; : { type: &quot;f&quot;, value: 1.0 }

		},

		vertexShader: [

			&quot;varying vec3 vNormal;&quot;,

			THREE.ShaderChunk[ &quot;morphtarget_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				&quot;vNormal = normalize( normalMatrix * normal );&quot;,

				THREE.ShaderChunk[ &quot;morphtarget_vertex&quot; ],
				THREE.ShaderChunk[ &quot;default_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform float opacity;&quot;,
			&quot;varying vec3 vNormal;&quot;,

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with &quot;lights: true&quot; material option)
	 ------------------------------------------------------------------------- */

	&#x27;normalmap&#x27; : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ &quot;fog&quot; ],
			THREE.UniformsLib[ &quot;lights&quot; ],
			THREE.UniformsLib[ &quot;shadowmap&quot; ],

			{

			&quot;enableAO&quot;		  : { type: &quot;i&quot;, value: 0 },
			&quot;enableDiffuse&quot;	  : { type: &quot;i&quot;, value: 0 },
			&quot;enableSpecular&quot;  : { type: &quot;i&quot;, value: 0 },
			&quot;enableReflection&quot;: { type: &quot;i&quot;, value: 0 },
			&quot;enableDisplacement&quot;: { type: &quot;i&quot;, value: 0 },

			&quot;tDisplacement&quot;: { type: &quot;t&quot;, value: null }, // must go first as this is vertex texture
			&quot;tDiffuse&quot;	   : { type: &quot;t&quot;, value: null },
			&quot;tCube&quot;		   : { type: &quot;t&quot;, value: null },
			&quot;tNormal&quot;	   : { type: &quot;t&quot;, value: null },
			&quot;tSpecular&quot;	   : { type: &quot;t&quot;, value: null },
			&quot;tAO&quot;		   : { type: &quot;t&quot;, value: null },

			&quot;uNormalScale&quot;: { type: &quot;v2&quot;, value: new THREE.Vector2( 1, 1 ) },

			&quot;uDisplacementBias&quot;: { type: &quot;f&quot;, value: 0.0 },
			&quot;uDisplacementScale&quot;: { type: &quot;f&quot;, value: 1.0 },

			&quot;diffuse&quot;: { type: &quot;c&quot;, value: new THREE.Color( 0xffffff ) },
			&quot;specular&quot;: { type: &quot;c&quot;, value: new THREE.Color( 0x111111 ) },
			&quot;ambient&quot;: { type: &quot;c&quot;, value: new THREE.Color( 0xffffff ) },
			&quot;shininess&quot;: { type: &quot;f&quot;, value: 30 },
			&quot;opacity&quot;: { type: &quot;f&quot;, value: 1 },

			&quot;useRefract&quot;: { type: &quot;i&quot;, value: 0 },
			&quot;refractionRatio&quot;: { type: &quot;f&quot;, value: 0.98 },
			&quot;reflectivity&quot;: { type: &quot;f&quot;, value: 0.5 },

			&quot;uOffset&quot; : { type: &quot;v2&quot;, value: new THREE.Vector2( 0, 0 ) },
			&quot;uRepeat&quot; : { type: &quot;v2&quot;, value: new THREE.Vector2( 1, 1 ) },

			&quot;wrapRGB&quot;  : { type: &quot;v3&quot;, value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			&quot;uniform vec3 ambient;&quot;,
			&quot;uniform vec3 diffuse;&quot;,
			&quot;uniform vec3 specular;&quot;,
			&quot;uniform float shininess;&quot;,
			&quot;uniform float opacity;&quot;,

			&quot;uniform bool enableDiffuse;&quot;,
			&quot;uniform bool enableSpecular;&quot;,
			&quot;uniform bool enableAO;&quot;,
			&quot;uniform bool enableReflection;&quot;,

			&quot;uniform sampler2D tDiffuse;&quot;,
			&quot;uniform sampler2D tNormal;&quot;,
			&quot;uniform sampler2D tSpecular;&quot;,
			&quot;uniform sampler2D tAO;&quot;,

			&quot;uniform samplerCube tCube;&quot;,

			&quot;uniform vec2 uNormalScale;&quot;,

			&quot;uniform bool useRefract;&quot;,
			&quot;uniform float refractionRatio;&quot;,
			&quot;uniform float reflectivity;&quot;,

			&quot;varying vec3 vTangent;&quot;,
			&quot;varying vec3 vBinormal;&quot;,
			&quot;varying vec3 vNormal;&quot;,
			&quot;varying vec2 vUv;&quot;,

			&quot;uniform vec3 ambientLightColor;&quot;,

			&quot;#if MAX_DIR_LIGHTS &gt; 0&quot;,

				&quot;uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];&quot;,
				&quot;uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];&quot;,

			&quot;#endif&quot;,

			&quot;#if MAX_HEMI_LIGHTS &gt; 0&quot;,

				&quot;uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];&quot;,
				&quot;uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];&quot;,
				&quot;uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];&quot;,

			&quot;#endif&quot;,

			&quot;#if MAX_POINT_LIGHTS &gt; 0&quot;,

				&quot;uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];&quot;,
				&quot;uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];&quot;,
				&quot;uniform float pointLightDistance[ MAX_POINT_LIGHTS ];&quot;,

			&quot;#endif&quot;,

			&quot;#if MAX_SPOT_LIGHTS &gt; 0&quot;,

				&quot;uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];&quot;,
				&quot;uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];&quot;,
				&quot;uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];&quot;,
				&quot;uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];&quot;,
				&quot;uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];&quot;,
				&quot;uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];&quot;,

			&quot;#endif&quot;,

			&quot;#ifdef WRAP_AROUND&quot;,

				&quot;uniform vec3 wrapRGB;&quot;,

			&quot;#endif&quot;,

			&quot;varying vec3 vWorldPosition;&quot;,
			&quot;varying vec3 vViewPosition;&quot;,

			THREE.ShaderChunk[ &quot;shadowmap_pars_fragment&quot; ],
			THREE.ShaderChunk[ &quot;fog_pars_fragment&quot; ],

			&quot;void main() {&quot;,

				&quot;gl_FragColor = vec4( vec3( 1.0 ), opacity );&quot;,

				&quot;vec3 specularTex = vec3( 1.0 );&quot;,

				&quot;vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;&quot;,
				&quot;normalTex.xy *= uNormalScale;&quot;,
				&quot;normalTex = normalize( normalTex );&quot;,

				&quot;if( enableDiffuse ) {&quot;,

					&quot;#ifdef GAMMA_INPUT&quot;,

						&quot;vec4 texelColor = texture2D( tDiffuse, vUv );&quot;,
						&quot;texelColor.xyz *= texelColor.xyz;&quot;,

						&quot;gl_FragColor = gl_FragColor * texelColor;&quot;,

					&quot;#else&quot;,

						&quot;gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );&quot;,

					&quot;#endif&quot;,

				&quot;}&quot;,

				&quot;if( enableAO ) {&quot;,

					&quot;#ifdef GAMMA_INPUT&quot;,

						&quot;vec4 aoColor = texture2D( tAO, vUv );&quot;,
						&quot;aoColor.xyz *= aoColor.xyz;&quot;,

						&quot;gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;&quot;,

					&quot;#else&quot;,

						&quot;gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;&quot;,

					&quot;#endif&quot;,

				&quot;}&quot;,

				&quot;if( enableSpecular )&quot;,
					&quot;specularTex = texture2D( tSpecular, vUv ).xyz;&quot;,

				&quot;mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );&quot;,
				&quot;vec3 finalNormal = tsb * normalTex;&quot;,

				&quot;#ifdef FLIP_SIDED&quot;,

					&quot;finalNormal = -finalNormal;&quot;,

				&quot;#endif&quot;,

				&quot;vec3 normal = normalize( finalNormal );&quot;,
				&quot;vec3 viewPosition = normalize( vViewPosition );&quot;,

				// point lights

				&quot;#if MAX_POINT_LIGHTS &gt; 0&quot;,

					&quot;vec3 pointDiffuse = vec3( 0.0 );&quot;,
					&quot;vec3 pointSpecular = vec3( 0.0 );&quot;,

					&quot;for ( int i = 0; i &lt; MAX_POINT_LIGHTS; i ++ ) {&quot;,

						&quot;vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );&quot;,
						&quot;vec3 pointVector = lPosition.xyz + vViewPosition.xyz;&quot;,

						&quot;float pointDistance = 1.0;&quot;,
						&quot;if ( pointLightDistance[ i ] &gt; 0.0 )&quot;,
							&quot;pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );&quot;,

						&quot;pointVector = normalize( pointVector );&quot;,

						// diffuse

						&quot;#ifdef WRAP_AROUND&quot;,

							&quot;float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );&quot;,
							&quot;float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );&quot;,

							&quot;vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );&quot;,

						&quot;#else&quot;,

							&quot;float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );&quot;,

						&quot;#endif&quot;,

						&quot;pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;&quot;,

						// specular

						&quot;vec3 pointHalfVector = normalize( pointVector + viewPosition );&quot;,
						&quot;float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );&quot;,
						&quot;float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );&quot;,

						// 2.0 =&gt; 2.0001 is hack to work around ANGLE bug

						&quot;float specularNormalization = ( shininess + 2.0001 ) / 8.0;&quot;,

						&quot;vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );&quot;,
						&quot;pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;&quot;,

					&quot;}&quot;,

				&quot;#endif&quot;,

				// spot lights

				&quot;#if MAX_SPOT_LIGHTS &gt; 0&quot;,

					&quot;vec3 spotDiffuse = vec3( 0.0 );&quot;,
					&quot;vec3 spotSpecular = vec3( 0.0 );&quot;,

					&quot;for ( int i = 0; i &lt; MAX_SPOT_LIGHTS; i ++ ) {&quot;,

						&quot;vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );&quot;,
						&quot;vec3 spotVector = lPosition.xyz + vViewPosition.xyz;&quot;,

						&quot;float spotDistance = 1.0;&quot;,
						&quot;if ( spotLightDistance[ i ] &gt; 0.0 )&quot;,
							&quot;spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );&quot;,

						&quot;spotVector = normalize( spotVector );&quot;,

						&quot;float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );&quot;,

						&quot;if ( spotEffect &gt; spotLightAngleCos[ i ] ) {&quot;,

							&quot;spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );&quot;,

							// diffuse

							&quot;#ifdef WRAP_AROUND&quot;,

								&quot;float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );&quot;,
								&quot;float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );&quot;,

								&quot;vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );&quot;,

							&quot;#else&quot;,

								&quot;float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );&quot;,

							&quot;#endif&quot;,

							&quot;spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;&quot;,

							// specular

							&quot;vec3 spotHalfVector = normalize( spotVector + viewPosition );&quot;,
							&quot;float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );&quot;,
							&quot;float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );&quot;,

							// 2.0 =&gt; 2.0001 is hack to work around ANGLE bug

							&quot;float specularNormalization = ( shininess + 2.0001 ) / 8.0;&quot;,

							&quot;vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );&quot;,
							&quot;spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;&quot;,

						&quot;}&quot;,

					&quot;}&quot;,

				&quot;#endif&quot;,

				// directional lights

				&quot;#if MAX_DIR_LIGHTS &gt; 0&quot;,

					&quot;vec3 dirDiffuse = vec3( 0.0 );&quot;,
					&quot;vec3 dirSpecular = vec3( 0.0 );&quot;,

					&quot;for( int i = 0; i &lt; MAX_DIR_LIGHTS; i++ ) {&quot;,

						&quot;vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );&quot;,
						&quot;vec3 dirVector = normalize( lDirection.xyz );&quot;,

						// diffuse

						&quot;#ifdef WRAP_AROUND&quot;,

							&quot;float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );&quot;,
							&quot;float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );&quot;,

							&quot;vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );&quot;,

						&quot;#else&quot;,

							&quot;float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );&quot;,

						&quot;#endif&quot;,

						&quot;dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;&quot;,

						// specular

						&quot;vec3 dirHalfVector = normalize( dirVector + viewPosition );&quot;,
						&quot;float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );&quot;,
						&quot;float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );&quot;,

						// 2.0 =&gt; 2.0001 is hack to work around ANGLE bug

						&quot;float specularNormalization = ( shininess + 2.0001 ) / 8.0;&quot;,

						&quot;vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );&quot;,
						&quot;dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;&quot;,

					&quot;}&quot;,

				&quot;#endif&quot;,

				// hemisphere lights

				&quot;#if MAX_HEMI_LIGHTS &gt; 0&quot;,

					&quot;vec3 hemiDiffuse  = vec3( 0.0 );&quot;,
					&quot;vec3 hemiSpecular = vec3( 0.0 );&quot; ,

					&quot;for( int i = 0; i &lt; MAX_HEMI_LIGHTS; i ++ ) {&quot;,

						&quot;vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );&quot;,
						&quot;vec3 lVector = normalize( lDirection.xyz );&quot;,

						// diffuse

						&quot;float dotProduct = dot( normal, lVector );&quot;,
						&quot;float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;&quot;,

						&quot;vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );&quot;,

						&quot;hemiDiffuse += diffuse * hemiColor;&quot;,

						// specular (sky light)


						&quot;vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );&quot;,
						&quot;float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;&quot;,
						&quot;float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );&quot;,

						// specular (ground light)

						&quot;vec3 lVectorGround = -lVector;&quot;,

						&quot;vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );&quot;,
						&quot;float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;&quot;,
						&quot;float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );&quot;,

						&quot;float dotProductGround = dot( normal, lVectorGround );&quot;,

						// 2.0 =&gt; 2.0001 is hack to work around ANGLE bug

						&quot;float specularNormalization = ( shininess + 2.0001 ) / 8.0;&quot;,

						&quot;vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );&quot;,
						&quot;vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );&quot;,
						&quot;hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );&quot;,

					&quot;}&quot;,

				&quot;#endif&quot;,

				// all lights contribution summation

				&quot;vec3 totalDiffuse = vec3( 0.0 );&quot;,
				&quot;vec3 totalSpecular = vec3( 0.0 );&quot;,

				&quot;#if MAX_DIR_LIGHTS &gt; 0&quot;,

					&quot;totalDiffuse += dirDiffuse;&quot;,
					&quot;totalSpecular += dirSpecular;&quot;,

				&quot;#endif&quot;,

				&quot;#if MAX_HEMI_LIGHTS &gt; 0&quot;,

					&quot;totalDiffuse += hemiDiffuse;&quot;,
					&quot;totalSpecular += hemiSpecular;&quot;,

				&quot;#endif&quot;,

				&quot;#if MAX_POINT_LIGHTS &gt; 0&quot;,

					&quot;totalDiffuse += pointDiffuse;&quot;,
					&quot;totalSpecular += pointSpecular;&quot;,

				&quot;#endif&quot;,

				&quot;#if MAX_SPOT_LIGHTS &gt; 0&quot;,

					&quot;totalDiffuse += spotDiffuse;&quot;,
					&quot;totalSpecular += spotSpecular;&quot;,

				&quot;#endif&quot;,

				&quot;#ifdef METAL&quot;,

					&quot;gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );&quot;,

				&quot;#else&quot;,

					&quot;gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;&quot;,

				&quot;#endif&quot;,

				&quot;if ( enableReflection ) {&quot;,

					&quot;vec3 vReflect;&quot;,
					&quot;vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );&quot;,

					&quot;if ( useRefract ) {&quot;,

						&quot;vReflect = refract( cameraToVertex, normal, refractionRatio );&quot;,

					&quot;} else {&quot;,

						&quot;vReflect = reflect( cameraToVertex, normal );&quot;,

					&quot;}&quot;,

					&quot;vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );&quot;,

					&quot;#ifdef GAMMA_INPUT&quot;,

						&quot;cubeColor.xyz *= cubeColor.xyz;&quot;,

					&quot;#endif&quot;,

					&quot;gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );&quot;,

				&quot;}&quot;,

				THREE.ShaderChunk[ &quot;shadowmap_fragment&quot; ],
				THREE.ShaderChunk[ &quot;linear_to_gamma_fragment&quot; ],
				THREE.ShaderChunk[ &quot;fog_fragment&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		vertexShader: [

			&quot;attribute vec4 tangent;&quot;,

			&quot;uniform vec2 uOffset;&quot;,
			&quot;uniform vec2 uRepeat;&quot;,

			&quot;uniform bool enableDisplacement;&quot;,

			&quot;#ifdef VERTEX_TEXTURES&quot;,

				&quot;uniform sampler2D tDisplacement;&quot;,
				&quot;uniform float uDisplacementScale;&quot;,
				&quot;uniform float uDisplacementBias;&quot;,

			&quot;#endif&quot;,

			&quot;varying vec3 vTangent;&quot;,
			&quot;varying vec3 vBinormal;&quot;,
			&quot;varying vec3 vNormal;&quot;,
			&quot;varying vec2 vUv;&quot;,

			&quot;varying vec3 vWorldPosition;&quot;,
			&quot;varying vec3 vViewPosition;&quot;,

			THREE.ShaderChunk[ &quot;skinning_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;shadowmap_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;skinbase_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinnormal_vertex&quot; ],

				// normal, tangent and binormal vectors

				&quot;#ifdef USE_SKINNING&quot;,

					&quot;vNormal = normalize( normalMatrix * skinnedNormal.xyz );&quot;,

					&quot;vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );&quot;,
					&quot;vTangent = normalize( normalMatrix * skinnedTangent.xyz );&quot;,

				&quot;#else&quot;,

					&quot;vNormal = normalize( normalMatrix * normal );&quot;,
					&quot;vTangent = normalize( normalMatrix * tangent.xyz );&quot;,

				&quot;#endif&quot;,

				&quot;vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );&quot;,

				&quot;vUv = uv * uRepeat + uOffset;&quot;,

				// displacement mapping

				&quot;vec3 displacedPosition;&quot;,

				&quot;#ifdef VERTEX_TEXTURES&quot;,

					&quot;if ( enableDisplacement ) {&quot;,

						&quot;vec3 dv = texture2D( tDisplacement, uv ).xyz;&quot;,
						&quot;float df = uDisplacementScale * dv.x + uDisplacementBias;&quot;,
						&quot;displacedPosition = position + normalize( normal ) * df;&quot;,

					&quot;} else {&quot;,

						&quot;#ifdef USE_SKINNING&quot;,

							&quot;vec4 skinVertex = vec4( position, 1.0 );&quot;,

							&quot;vec4 skinned  = boneMatX * skinVertex * skinWeight.x;&quot;,
							&quot;skinned 	  += boneMatY * skinVertex * skinWeight.y;&quot;,

							&quot;displacedPosition  = skinned.xyz;&quot;,

						&quot;#else&quot;,

							&quot;displacedPosition = position;&quot;,

						&quot;#endif&quot;,

					&quot;}&quot;,

				&quot;#else&quot;,

					&quot;#ifdef USE_SKINNING&quot;,

						&quot;vec4 skinVertex = vec4( position, 1.0 );&quot;,

						&quot;vec4 skinned  = boneMatX * skinVertex * skinWeight.x;&quot;,
						&quot;skinned 	  += boneMatY * skinVertex * skinWeight.y;&quot;,

						&quot;displacedPosition  = skinned.xyz;&quot;,

					&quot;#else&quot;,

						&quot;displacedPosition = position;&quot;,

					&quot;#endif&quot;,

				&quot;#endif&quot;,

				//

				&quot;vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );&quot;,
				&quot;vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );&quot;,

				&quot;gl_Position = projectionMatrix * mvPosition;&quot;,

				//

				&quot;vWorldPosition = worldPosition.xyz;&quot;,
				&quot;vViewPosition = -mvPosition.xyz;&quot;,

				// shadows

				&quot;#ifdef USE_SHADOWMAP&quot;,

					&quot;for( int i = 0; i &lt; MAX_SHADOWS; i ++ ) {&quot;,

						&quot;vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;&quot;,

					&quot;}&quot;,

				&quot;#endif&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	&#x27;cube&#x27;: {

		uniforms: { &quot;tCube&quot;: { type: &quot;t&quot;, value: null },
					&quot;tFlip&quot;: { type: &quot;f&quot;, value: -1 } },

		vertexShader: [

			&quot;varying vec3 vWorldPosition;&quot;,

			&quot;void main() {&quot;,

				&quot;vec4 worldPosition = modelMatrix * vec4( position, 1.0 );&quot;,
				&quot;vWorldPosition = worldPosition.xyz;&quot;,

				&quot;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;uniform samplerCube tCube;&quot;,
			&quot;uniform float tFlip;&quot;,

			&quot;varying vec3 vWorldPosition;&quot;,

			&quot;void main() {&quot;,

				&quot;gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;)

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	&#x27;depthRGBA&#x27;: {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ &quot;morphtarget_pars_vertex&quot; ],
			THREE.ShaderChunk[ &quot;skinning_pars_vertex&quot; ],

			&quot;void main() {&quot;,

				THREE.ShaderChunk[ &quot;skinbase_vertex&quot; ],
				THREE.ShaderChunk[ &quot;morphtarget_vertex&quot; ],
				THREE.ShaderChunk[ &quot;skinning_vertex&quot; ],
				THREE.ShaderChunk[ &quot;default_vertex&quot; ],

			&quot;}&quot;

		].join(&quot;\n&quot;),

		fragmentShader: [

			&quot;vec4 pack_depth( const in float depth ) {&quot;,

				&quot;const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );&quot;,
				&quot;const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );&quot;,
				&quot;vec4 res = fract( depth * bit_shift );&quot;,
				&quot;res -= res.xxyz * bit_mask;&quot;,
				&quot;return res;&quot;,

			&quot;}&quot;,

			&quot;void main() {&quot;,

				&quot;gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );&quot;,

				//&quot;gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );&quot;,
				//&quot;float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );&quot;,
				//&quot;gl_FragData[ 0 ] = pack_depth( z );&quot;,
				//&quot;gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );&quot;,

			&quot;}&quot;

		].join(&quot;\n&quot;)

	}

};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
